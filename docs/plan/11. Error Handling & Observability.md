## 11. Error Handling & Observability

### 11.1 Overview

This section defines how AshTrail detects, classifies, records, and responds to errors at runtime.  
The goal is to:

- Prevent silent failures
- Preserve user trust and data integrity
- Enable debugging without external observability infrastructure
- Support future expansion into analytics or remote telemetry

AshTrail is intentionally offline-first and single-user per account; error handling favors **local resilience and transparency** over centralized reporting.

---

### 11.2 Responsibilities

The error handling and observability layer is responsible for:

- Classifying errors into actionable categories
- Ensuring failures are logged consistently
- Providing safe recovery paths without data loss
- Avoiding crashes caused by non-fatal issues
- Preserving enough context to debug issues after the fact

Non-responsibilities:

- No real-time alerting
- No crash reporting to third-party services
- No automatic remote log uploads

---

### 11.3 Error Classification

Errors are grouped by **source and impact**, not by exception type.

### 11.3.1 User Errors

Errors caused by invalid user actions or inputs.

##### Characteristics

- Predictable
- Recoverable
- Do not indicate a bug

##### Examples

- Submitting a log with missing required fields
- Selecting an account that no longer exists
- Entering invalid numeric values (e.g., negative duration)

##### Handling Rules

- Do not crash
- Display user-facing feedback
- Do not log as system failures
- May be logged as debug events (optional)

##### Visibility

- UI-level validation messages
- Snackbars / inline error text

---

### 11.3.2 System Errors

Errors caused by internal failures or unexpected state.

##### Characteristics

- Unpredictable
- May indicate bugs or data corruption
- Require investigation

##### Examples

- Hive read/write failure
- Deserialization errors
- State mismatch between providers
- Unhandled exceptions in async flows

##### Handling Rules

- Log immediately
- Preserve context (stack trace, state snapshot)
- Attempt graceful degradation when possible
- Fail fast only if data integrity is at risk

##### Visibility

- Not always visible to the user
- May surface as generic error messages

---

### 11.4 Logging Strategy

AshTrail uses **structured local logging** for observability.  
Logs are not intended for user consumption but for debugging and auditability.

### 11.4.1 Debug Logs

Used during development and troubleshooting.

##### Purpose

- Trace state transitions
- Diagnose unexpected behavior
- Verify assumptions during feature work

##### Characteristics

- Verbose
- Not persisted long-term (implementation-dependent)
- Safe to disable in production builds

##### Typical Contents

- Provider lifecycle events
- State changes
- Function entry/exit
- Non-fatal exceptions

##### Constraints

- Must not include sensitive user data
- Must not impact performance in release mode

---

### 11.4.2 Audit Logs

Used to record **meaningful system events**.

##### Purpose

- Track data mutations
- Reconstruct timelines
- Support future analytics

##### Examples

- Log entry created / updated / deleted
- Account switched
- Sync attempted or failed
- Recovery action triggered

##### Characteristics

- Structured
- Deterministic
- Persisted locally

##### Relationship to Logging System

- Audit logs may reuse the core logging infrastructure
- Distinct from user log entries (smoking/activity logs)

---

### 11.5 Recovery Paths

Recovery is preferred over failure whenever it does not compromise correctness.

### 11.5.1 Retry Logic

Retries are applied selectively and explicitly.

##### Eligible Operations

- Local persistence writes
- Background sync operations
- Non-idempotent operations only if safe

##### Rules

- Never infinite retries
- Use capped retry counts
- Prefer retry with delay over immediate retry
- Abort if state changes invalidate the operation

##### Non-Goals

- No global retry middleware
- No silent retries for user-triggered actions without feedback

---

### 11.6 State & Flow

High-level error flow:

1. Operation begins
2. Failure occurs
3. Error is classified
4. Appropriate log is recorded
5. Recovery attempted if applicable
6. User notified only if actionable

Error handling must not mutate state unless explicitly part of recovery logic.

---

### 11.7 Edge Cases & Failure Modes

- Corrupted local database
- Partial writes during app termination
- Provider initialization failures
- Version mismatch after app upgrade
- State deserialization errors after schema changes

Each must fail safely without cascading crashes.

---

### 11.8 Assumptions

- App runs without guaranteed network access
- Single active user per device at a time
- Logs are primarily developer-facing
- No legal or compliance audit requirements

---

### 11.9 Open Questions

- Should audit logs be queryable via UI?
- Should error events be surfaced in analytics views?
- Is a structured error model (ErrorCode enum) required?
- Should retry behavior be configurable per feature?

---

### 11.10 Future Extensions

Clearly out of scope for current implementation:

- Remote error reporting
- Crash analytics integration
- User-accessible diagnostics export
- Structured telemetry pipelines
- Background health checks

---
