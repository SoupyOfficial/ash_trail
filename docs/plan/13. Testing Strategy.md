## 13. Testing Strategy

### Overview
Defines how AshTrail is tested to ensure correctness, stability, and regressions are caught early.  
Testing prioritizes deterministic behavior, offline-first correctness, and multi-account safety.

---

### 13.1 Unit Tests

### Unit Tests Overview
Unit tests validate pure logic without Flutter widgets, platform services, or external I/O.  
They serve as the first line of defense against logic regressions.

### Unit Tests Responsibilities
- Verify domain rules and invariants
- Ensure state reducers and helpers behave deterministically
- Validate serialization and transformation logic

### 13.1.1 Domain Logic

#### Covered Areas
- Log entry creation and normalization
- Duration calculations
- Time utilities (relative time, formatting)
- Validation helpers (input bounds, required fields)
- Aggregation helpers (daily, rolling windows)

#### Data Structures Tested
| Component | Focus |
|---------|------|
| LogEntry | Field validity, defaults, serialization |
| Session | State transitions |
| Aggregates | Correct grouping and totals |

#### Constraints
- No use of `DateTime.now()` directly
- Time must be injected or mocked
- Tests must be deterministic and repeatable

#### Domain Logic Edge Cases & Failure Modes
- Zero-length durations
- Invalid timestamps
- Missing optional fields
- Large data sets causing overflow or precision issues

#### Domain Logic Assumptions
- Domain logic is fully decoupled from Flutter
- Pure Dart tests run quickly and frequently

#### Domain Logic Open Questions
- Is property-based testing desired for aggregates?
- Should fuzz testing be introduced for parsers?

---

### 13.2 Widget Tests

### Widget Tests Overview
Widget tests validate UI behavior in isolation without real network or storage.

### Widget Tests Responsibilities
- Verify widgets render expected states
- Validate user input handling
- Ensure visual feedback matches state

### 13.2.1 Form Validation

#### Covered Forms
- Log entry input
- Account creation / switching
- Filters and date selectors

#### Validation Scenarios
- Required fields missing
- Invalid numeric ranges
- Disabled submit on invalid state
- Error messages displayed correctly

#### Form Validation State Flow
1. Widget rendered with initial state
2. User input simulated
3. Validation triggered
4. UI reacts (error text, button state)

#### Form Validation Edge Cases & Failure Modes
- Rapid input changes
- Form submission spam
- Keyboard dismissal mid-input

#### Form Validation Assumptions
- Validation logic is centralized, not duplicated per widget

#### Form Validation Open Questions
- Should golden tests be added for critical screens?

---

### 13.3 Integration Tests

### Integration Tests Overview
Integration tests validate end-to-end behavior across state, persistence, and sync layers.

### Integration Tests Responsibilities
- Ensure systems work together correctly
- Catch issues not visible in isolation

### 13.3.1 Sync Scenarios

#### Covered Scenarios
- Offline log creation → later sync
- Conflict resolution between local and remote data
- Account switching with pending sync
- Partial sync failures

#### Sync Scenarios State Flow
1. App starts offline
2. User creates data
3. App transitions online
4. Sync engine runs
5. Remote and local states converge

#### Sync Scenarios Edge Cases & Failure Modes
- Network flapping during sync
- Duplicate uploads
- Corrupted local cache
- Auth token expiration mid-sync

#### Sync Scenarios Assumptions
- A mock or staging backend is available
- Sync logic is idempotent

#### Sync Scenarios Open Questions
- How are sync conflicts surfaced to the user?
- Should sync retries be time-based or event-based?

---

### 13.4 Manual Testing

### Manual Testing Overview
Manual testing complements automated tests for UX, rare edge cases, and exploratory scenarios.

### Manual Testing Responsibilities
- Validate real-device behavior
- Catch usability issues
- Verify platform-specific behavior

### 13.4.1 Edge Case Checklists

#### General
- App kill and resume during critical actions
- Background → foreground transitions
- Low battery / low memory conditions

#### Data
- Large historical datasets
- Rapid account switching
- Deleting accounts with existing logs

#### UI
- Small screen devices
- Accessibility font scaling
- Dark mode / light mode transitions

#### Sync
- Airplane mode toggling
- Login/logout during sync
- Corrupted or missing remote data

#### Manual Testing Assumptions
- Manual testing is performed before releases
- Issues found are converted into automated tests when possible

---

### Future Extensions
- Automated performance benchmarks
- Load testing for large datasets
- Chaos testing for sync reliability
- CI-enforced coverage thresholds

---
