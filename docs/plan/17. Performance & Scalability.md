## 17. Performance & Scalability

### 17.1 Performance Targets

#### 17.1.1 App Startup Time

##### Overview

Defines acceptable startup latency to ensure the app feels responsive and usable on first launch and resume.

##### Responsibilities
- Minimize time to first interactive frame
- Avoid blocking I/O or synchronous initialization on startup
- Defer non-critical initialization

##### Targets

- Cold start (app not resident): ≤ 1.5 seconds on mid-range devices
- Warm start (app in memory): ≤ 500 ms
- Resume from background: ≤ 300 ms

##### State & Flow

- App launches
- Core services initialize (config, local DB, account state)
- UI renders minimal shell
- Deferred services initialize asynchronously

##### Edge Cases & Failure Modes

- Slow disk I/O during local database initialization
- Corrupt local cache causing blocking recovery logic
- Excessive synchronous providers during startup

##### Future Extensions

- Startup tracing and metrics collection
- Lazy-loading of non-critical providers


#### 17.1.2 Log Entry Creation Latency

##### Overview

Ensures log creation feels instantaneous to the user.

##### Responsibilities
- Capture user input
- Persist log locally
- Update UI state immediately

##### Targets

- End-to-end latency (tap → UI confirmation): ≤ 100 ms
- Local write latency: ≤ 50 ms

##### State & Flow

- User submits log
- Log is validated synchronously
- Log written to local database
- UI state updates optimistically

##### Edge Cases & Failure Modes

- Disk contention delaying writes
- Validation errors blocking persistence
- Large datasets increasing write overhead

##### Future Extensions

- Background batching for non-critical fields
- Write-ahead logging or buffering


---

### 17.2 Local Database Performance

#### 17.2.1 Index Usage

##### Overview

Indexes ensure predictable query performance as data volume grows.

##### Responsibilities
- Maintain indexes for common query patterns
- Avoid unnecessary or redundant indexes

##### Expected Indexes

- Account ID
- Timestamp (descending)
- Sync status

##### Constraints

- Index creation must not block app startup
- Index updates must occur automatically on write

##### Edge Cases & Failure Modes

- Missing index causing full-table scans
- Index bloat increasing memory usage

##### Open Questions

- Should compound indexes be introduced for analytics queries?


#### 17.2.2 Query Patterns

##### Overview

Defines supported and optimized query shapes.

##### Common Patterns
- Fetch recent logs for active account
- Fetch logs within time range
- Aggregate logs by day/week

##### Constraints

- Queries must be bounded (limit/offset or time window)
- No unbounded full-history scans in UI paths

##### Edge Cases & Failure Modes

- Large result sets causing UI jank
- Inefficient aggregation queries on-device

##### Future Extensions

- Pre-aggregated summaries
- Materialized views for analytics


---

### 17.3 Memory Management

#### 17.3.1 Large Dataset Handling

##### Overview

Ensures the app remains stable with long-term usage and large datasets.

##### Responsibilities
- Avoid loading full datasets into memory
- Stream or paginate data where possible

##### Strategies

- Pagination for history views
- Windowed queries for analytics
- Dispose unused providers promptly

##### Constraints

- No in-memory caching of entire log history
- Charts must operate on reduced datasets

##### Edge Cases & Failure Modes

- Memory pressure on low-RAM devices
- Provider leaks retaining large lists

##### Future Extensions

- Background compaction or archiving
- Configurable data retention policies


---

### 17.4 Sync Performance

#### 17.4.1 Batch Sizes

##### Overview

Controls how local logs are uploaded or synced efficiently.

##### Responsibilities
- Group multiple log entries per sync operation
- Balance throughput vs. memory usage

##### Assumed Defaults

- Batch size: 50–100 log entries
- Max payload size aligned with backend limits

##### State & Flow

- Identify unsynced logs
- Group into batches
- Upload sequentially or with limited parallelism

##### Edge Cases & Failure Modes

- Oversized batches causing request failures
- Too-small batches increasing overhead

##### Open Questions

- Should batch size adapt dynamically based on network conditions?


#### 17.4.2 Throttling Rules

##### Overview

Prevents excessive sync attempts and conserves resources.

##### Responsibilities
- Limit sync frequency
- Back off on repeated failures

##### Rules

- Minimum interval between sync attempts
- Exponential backoff on errors
- Pause sync when offline or backgrounded

##### Edge Cases & Failure Modes

- Sync storms after reconnect
- Starvation if backoff never resets

##### Future Extensions

- Network-aware throttling
- User-configurable sync behavior


---

### 17.5 Scalability Assumptions

#### 17.5.1 Single-User Data Volume Limits

##### Overview

Defines expected data scale to guide architectural decisions.

##### Assumptions
- Single primary user per app install
- No concurrent multi-user write access

##### Estimated Limits

- Log entries: up to ~100,000 per user
- Data growth: linear over time
- Sync backend scales independently

##### Constraints

- Local storage must handle multi-year usage
- Performance must degrade gracefully beyond expected limits

##### Edge Cases & Failure Modes

- Unexpected data spikes
- Migration issues with very large datasets

##### Open Questions

- Should hard caps or warnings be enforced?
- Is long-term archival required?

---
