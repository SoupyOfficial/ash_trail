## 24. Developer Workflow
### 24.1 Local Setup
#### 24.1.1 Environment Requirements

##### Required tooling

- Flutter SDK
  - Stable channel
  - Version: *must match the version pinned in the repo*  
    - Assumption: version is defined via `flutter --version` expectation or CI config
- Dart SDK
  - Comes bundled with Flutter
- Platform SDKs
  - Android: Android Studio + SDK tools
  - iOS (macOS only): Xcode + Command Line Tools
- Git
- IDE (recommended, not required)
  - VS Code or Android Studio with Flutter/Dart plugins
  

##### Environment configuration

- Clone repository:
  ```bash

  git clone https://github.com/SoupyOfficial/AshTrail.git

  cd AshTrail
```
- Fetch dependencies:
	```bash
flutter pub get
 ```
 
- Verify setup:
```bash
flutter doctor
```

##### Assumptions

- No local .env file is required
- Environment selection (dev/prod) is handled via build flavors or compile-time flags  

##### Open questions

- Is a specific Flutter version locked via FVM or CI?
- Are platform-specific signing configs required for local builds?


### 24.2 Running the App
#### 24.2.1 Debug Mode

##### Standard debug run

```bash
flutter run
```
- Uses debug flavor by default
- Enables: 
	- Hot reload
	- Verbose error messages
	- Debug logging

##### Targeting a specific device

```bash
flutter devices

flutter run -d <device_id>

##### Flavor-based execution (if applicable)

flutter run --flavor dev
```

##### Assumptions

- Debug mode uses:  
	- Local database
	- Development backend / Firebase project
- No production data is written during debug runs

##### Open questions

- Are multiple Firebase projects configured per flavor?
- Is debug mode fully offline-capable by default?


### 24.3 Common Tasks
#### 24.3.1 Adding a Log Field

##### Typical workflow

1. Update the domain model  
	- Add field to log record entity/model
2. Update local persistence schema  
	- Hive adapter / serialization logic
3. Update remote sync mapping  
	- Firestore field mapping (if applicable)
4. Update UI  
	- Logging form input
	- Validation rules
5. Update analytics & aggregation logic  
	- Ensure new field is included or explicitly ignored
6. Run migrations (if required)

##### Checklist

- Field added to model
- Serialization updated
- Backward compatibility handled
- UI validation updated
- Analytics unaffected or updated intentionally

##### Failure risk

- Old records missing the new field
- Hive adapter version mismatch

#### 24.3.2 Schema Changes

##### Local schema changes

- Increment adapter version if required
- Provide default values for new fields
- Never remove fields without a migration strategy

##### Remote schema changes

- Firestore is schema-less, but:  
	- Existing documents may not contain new fields
	- Client must handle missing/null values safely
  
##### Recommended approach

- Additive changes only
- Treat all new fields as optional until fully backfilled

##### Open questions

- Is there a formal migration versioning strategy?
- Are destructive schema changes allowed in any environment?

### 24.4 Debugging
#### 24.4.1 Logging Strategy

##### Logging levels

- Debug  
	- State transitions
	- Sync attempts
	- Data parsing
- Info  
	- User actions (non-sensitive)
	- Successful operations
- Error  
	- Failed sync
	- Corrupt data
	- Unexpected state

##### Where logs appear

- Console during debug runs
- Platform logs (Android Logcat / Xcode console)

##### Best practices

- Log state changes, not UI rebuilds
- Include record/account IDs where relevant
- Never log sensitive user data  

##### Anti-patterns

- Logging inside tight UI rebuild loops
- Logging full payloads unnecessarily

### 24.5 Known Gotchas
#### 24.5.1 Hot Reload Caveats

##### What hot reload does not handle well

- Changes to:  
	- Hive adapters
	- Model constructors
	- Serialization logic
	- Enum values
- Dependency injection graph changes
- Initial app state changes

##### Recommended actions

- Use hot restart instead of hot reload when:  
	- Changing data models
	- Modifying providers that initialize state
- Fully restart app when:  
	- Local schema changes occur
	- Unexpected state behavior appears

##### Symptom examples

- App runs but data appears incorrect
- State not reflecting code changes
- Silent failures after model updates  

##### Rule of thumb
If data shape changed: restart the app.

### 24.6 Future Extensions
- Automated developer bootstrap script
- Pre-commit hooks for formatting and linting
- Schema change checklist enforced via CI
- Local mock data seeding for development
- One-command environment verification

---
