## 25. Coding Standards

### 25.1 Overview

This section defines coding standards for the AshTrail codebase to ensure:
- Consistency across contributors
- Predictable state management
- Clear error-handling semantics
- Low cognitive overhead for future maintainers

These standards apply to all Dart/Flutter code unless explicitly exempted.

---

### 25.2 Responsibilities

The coding standards are responsible for:
- Enforcing consistent naming and file organization
- Preventing accidental state mutation
- Standardizing error-handling patterns
- Defining lint rules that catch issues early

They are **not** responsible for:
- Enforcing architectural boundaries (covered elsewhere)
- Runtime validation or business-rule enforcement

---

### 25.3 Data Structures

_No runtime data structures are introduced by this section._

However, these standards influence how data structures are authored.

---

### 25.4 State & Flow

#### 25.4.1 Naming Conventions

#### 25.4.1.1 Files

Rules:
- `snake_case.dart`
- One primary public construct per file
- File name reflects the main type or responsibility

Examples:
- `log_entry.dart`
- `account_repository.dart`
- `sync_state.dart`

Prohibited:
- `camelCase.dart`
- Mixed responsibilities in a single file
- Abbreviations without clear meaning

---

#### 25.4.1.2 Classes

Rules:
- `PascalCase`
- Nouns for data models
- Verb-noun for services or controllers

Examples:
- `LogEntry`
- `Account`
- `SyncManager`
- `ExportService`

Special cases:
- Abstract classes prefixed with `Base` or suffixed with `Contract`
- Mixins suffixed with `Mixin`

---

#### 25.4.2 Immutability Rules

#### 25.4.2.1 State Objects

Rules:
- All state objects must be immutable
- Fields are `final`
- Updates occur via `copyWith` or full replacement
- No in-place mutation

Required:
- Constructor initializes all required fields
- `copyWith` returns a new instance

Example pattern:
- `State -> NewState = state.copyWith(...)`

Prohibited:
- Mutating collections inside state
- Exposing mutable references
- Late-initialized state fields

Rationale:
- Predictable rebuilds
- Easier debugging
- Safer async flows

---

#### 25.4.3 Error Handling Patterns

#### 25.4.3.1 Result Types vs Exceptions

##### Preferred: Result Types

Use result-style returns for:
- Domain logic
- Validation
- Expected failure modes

##### Characteristics:

- Explicit success/failure
- Typed error information
- No control-flow via exceptions

##### Allowed: Exceptions

Use exceptions only for:
- Programmer errors
- Invariant violations
- Truly unexpected system failures

##### Rules:

- Do not use exceptions for normal control flow
- Catch exceptions at system boundaries
- Convert exceptions to user-safe errors before UI

---

#### 25.4.4 Linting

#### 25.4.4.1 Enforced Rules

##### Linting is mandatory and enforced via analysis configuration.

Expected rules (non-exhaustive):
- No unused imports
- No unused variables
- Prefer `const` constructors
- Avoid dynamic typing
- Explicit return types for public methods

##### Build impact:

- Lint violations fail CI
- Local builds should surface issues immediately

---

### 25.5 Edge Cases & Failure Modes

- Inconsistent adherence leads to:
  - Hard-to-track state bugs
  - Implicit mutation
  - Unclear error propagation
- Partial compliance is worse than strict enforcement
- Mixing patterns (exceptions + result types) increases complexity

---

### 25.6 Future Extensions

- Formal Result/Error type definition (shared across layers)
- Auto-format enforcement via pre-commit hooks
- Expanded lint rules for architectural constraints
- Documentation linting for public APIs

---

### 25.7 Assumptions & Open Questions

##### Assumptions

- Dart analysis options are already configured in the repo
- All contributors use the same formatter/linter versions

##### Open Questions

- Is there a canonical Result type already in use?
- Are exceptions ever surfaced directly to the UI layer?
- Should architectural linting (layer boundaries) be added later?

---
