## 27. Feature Flags & Experimental Work

### 27.1 Overview

Feature flags in AshTrail exist to:

- Reduce risk when shipping incomplete or high-impact changes.
- Support running experiments without forking the codebase.
- Enable rapid rollback by disabling a code path (when implemented as runtime flags).
- Keep development-only tooling out of production builds (compile-time gating).

This section defines:

- A flag strategy split into compile-time vs runtime.
- Rules for experimental feature gating.
- A cleanup/removal policy to prevent “flag graveyards”.

> Assumption: AshTrail already uses **build flavors** (Development vs Production) and may use **compile-time constants** for environment selection.
>
> Open question: Which mechanisms are currently implemented in-code (e.g., `--dart-define`, flavor-based entrypoints, config files)? This document describes the expected approach and what to verify in the repo.

---

### 27.2 Responsibilities

#### Owners

- **Feature author**
  - Proposes the flag, implements gating, adds tests, and sets removal criteria.
- **Reviewer**
  - Ensures gating is correct, tests exist, and cleanup policy is followed.
- **Maintainer**
  - Enforces periodic cleanup and prevents dead flags from persisting.

#### Core responsibilities

- Maintain a single, discoverable location for flag definitions (even if values are injected elsewhere).
- Ensure flags do not silently change persisted data formats without explicit migration/versioning.
- Ensure disabling a flag does not crash the app or strand user data.
- Ensure flags are observable in debug contexts (e.g., a diagnostics page or logs) without leaking secrets.

---

### 27.3 Data Structures (fields, types, constraints)

AshTrail should treat “flag definition” as metadata even if flags are implemented as raw constants.

#### 27.1 Flag Strategy — shared metadata model (documentation-level)

Use the following fields as the required information for any flag introduced:

- `key` (string, required)
  - Stable identifier (no spaces), e.g. `expRollingAnalyticsV2`
- `type` (enum: `bool`, `int`, `double`, `string`, required)
- `defaultValue` (type-matching, required)
- `scope` (enum: `compileTime`, `runtime`, required)
- `owner` (string, required)
- `createdAt` (date, required)
- `targetRemovalBy` (date, optional but strongly recommended)
- `description` (string, required)
- `gatingNotes` (string, optional)
  - What’s gated (UI only? domain logic? persistence?)
- `removalCriteria` (string, required)
  - What must be true for the flag to be deleted.
- `riskLevel` (enum: `low`, `medium`, `high`, required)
  - Used to enforce additional rules (see gating rules).

> Constraint: Any flag that gates persistence or sync behavior must be `riskLevel=high` and must include explicit rollback handling.

---

### 27.4 State & Flow (how data moves through the system)

#### 27.4.1 Compile-Time

**Definition**

- Compile-time flags are resolved at build time and cannot change while the app is running.
- Use cases:
  - Environment selection (dev/prod)
  - Stripping debug tooling from production
  - Hard-disabling experimental code paths for release builds
  - Enabling verbose logging / diagnostics only in dev

**Expected mechanisms (Flutter/Dart)**

- `--dart-define` values read via `const ...fromEnvironment(...)`
- Flavor-specific entrypoints / build configuration (Android productFlavors, iOS schemes)
- `kReleaseMode` / `kDebugMode` / `kProfileMode` for runtime-known build mode (still compile-time decided)

**Flow**

1. Build system injects values (flavor or `--dart-define`).
2. App startup reads compile-time constants.
3. Constants select:
   - Which services/adapters initialize
   - Which screens/tools are registered
   - Which code paths are reachable

**Hard rule**

- Compile-time flags may be used to exclude entire features from production artifacts.
- Do not use compile-time flags for user-facing toggles you expect to flip after release.

**Example pattern (illustrative)**

~~~dart
const bool enableDebugTools =
    bool.fromEnvironment('ASH_ENABLE_DEBUG_TOOLS', defaultValue: false);
~~~

> Open question: What are AshTrail’s current injected values (names and defaults)? Document the canonical list once confirmed in the repo.

#### 27.4.2 Runtime

**Definition**

- Runtime flags can be evaluated while the app runs and can change without rebuilding.
- Use cases:
  - Gradual rollout on a single device
  - Emergency kill-switch for risky behavior
  - Per-account enablement (if needed)

**Expected storage sources (choose one)**

- Local-only: persisted app settings (safe default for offline-first)
- Remote-config: fetched from backend and cached locally (requires explicit offline behavior)

**Flow**

1. App boot loads a runtime flag snapshot from local storage.
2. State layer exposes a read-only “flags view” to the UI/domain.
3. If remote-config exists:
   - Sync process refreshes flags in the background
   - New snapshot is persisted
   - Consumers update via provider/state refresh

**Hard rules**

- Runtime flag evaluation must be deterministic for a given snapshot.
- Runtime flags that affect persistence or sync must:
  - Be versioned
  - Have rollback rules
  - Be observable for debugging (e.g., included in exported diagnostics)

> Open questions:
>
> - Are runtime flags implemented today?
> - If yes, where are they stored, and how are they loaded into Riverpod?
> - If remote flags exist, how is offline behavior defined (stale TTL, failure fallback)?

---

### 27.5 Edge Cases & Failure Modes

#### Flag evaluation failures

- Missing key / parse error
  - Must fall back to `defaultValue` and log a debug warning in non-release builds.
- Conflicting sources (compile-time says off, runtime says on)
  - Compile-time wins if the code is compiled out / not reachable.
  - Otherwise define an explicit precedence order and document it.

#### Persistence and migration hazards (high risk)

- A flag changes:
  - schema fields written to local DB
  - Firestore document shape / sync semantics
  - aggregation derivations that are stored/cached
- Failure mode: disabling flag makes existing data unreadable or causes sync conflicts.

**Required mitigations**

- Any flag that impacts persisted formats must include:
  - forward-compat read logic (can read both shapes), or
  - migration with a version marker, or
  - explicit “flag cannot be disabled once enabled” behavior (documented and enforced)

#### Experimental UI gating pitfalls

- UI is hidden but routes/actions still reachable
  - Must gate navigation targets and any commands that mutate state.
- Partial gating creates “half-enabled” states
  - Prefer gating at a single composition root (feature module registration) vs scattered `if` checks.

---

### 27.6 Future Extensions (clearly labeled)

This section is non-binding; implement only if needed.

- Flag registry tooling
  - A generated page listing all flags, defaults, and current resolved values.
- Debug export bundle
  - Include current compile-time environment + runtime flag snapshot for bug reports.
- Automated cleanup checks (CI)
  - Fail PRs introducing flags without `removalCriteria`.
  - Warn when `targetRemovalBy` is exceeded.
- Safer experiment framework
  - Guardrails for “high-risk” flags:
    - Require migrations
    - Require rollback tests
    - Require explicit owner approval

---

### 27.7 Experimental Features

#### 27.7.1 Gating Rules

Experimental features must be gated based on risk level:

#### Low risk (UI-only; no persistence/sync impact)

- Allowed to gate at UI composition level.
- Must not write new persisted fields.
- Must be removable without data changes.

#### Medium risk (domain logic changes; derived calculations; analytics)

- Must include unit tests proving:
  - enabled behavior is correct
  - disabled behavior remains correct
- Must avoid storing derived outputs unless versioned.

#### High risk (persistence, sync, auth, account boundaries)

- Must include:
  - explicit rollback behavior
  - compatibility logic (read old + new forms), or a migration plan
  - integration test coverage including toggling scenarios

**Hard rule**

- “High risk” experiments cannot be “UI gated only”.
  - If the domain path exists, it must be gated at the domain boundary as well.

---

### 27.8 Cleanup Policy

#### 27.8.1 Flag Removal Criteria

Flags are temporary by default.

A flag must be removed when any of the following is true:

- The experiment is complete and the behavior is:
  - permanently adopted, or
  - permanently rejected.
- The flag has no active code paths (dead flag).
- The flag’s target removal date has passed and there is no documented extension.

**Removal checklist**

- Delete the flag definition (constant / config / key).
- Delete gated branches that are no longer used.
- Delete tests that only validate the removed branch, or rewrite tests to match the new permanent behavior.
- Remove any temporary UI controls or debug toggles.
- Verify migrations or dual-read logic are either:
  - no longer needed and removed, or
  - formalized as backward compatibility logic with version markers.

**Audit cadence (recommended)**

- Review all flags at least monthly.
- Any flag older than 90 days must either:
  - be removed, or
  - have a documented rationale + extended removal date.

---

### Assumptions & Open Questions (to resolve for implementation-accuracy)

- Are compile-time flags currently implemented via:
  - flavor entrypoints,
  - `--dart-define`,
  - or both?
- Is there any runtime flag mechanism implemented today?
  - If yes: where is the snapshot stored, and which provider exposes it?
- Are there existing “experiments” in the repo today that should be formalized as flags?
- What is the canonical naming convention for defines/flags (prefix, casing)?
- Do we need per-account runtime flags, or is global-per-device sufficient?

---
