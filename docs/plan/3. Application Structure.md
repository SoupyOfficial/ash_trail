## 3. Application Structure

### 3.1 Folder Layout

#### 3.1.1 `lib/`

The `lib/` directory is the root of all Dart source code for the application. It is organized to enforce separation of concerns, feature isolation, and controlled dependency flow.

High-level structure (conceptual):

- `lib/core/` — cross-cutting, dependency-free infrastructure
- `lib/features/` — self-contained application features
- `lib/main.dart` — application entry point (not documented here)

---

##### 3.1.1.1 `core/`

The `core/` directory contains foundational building blocks that are shared across all features.

Characteristics:
- Must not depend on any feature module
- Should remain stable over time
- Contains abstractions, utilities, and shared primitives
- Safe to import from anywhere in the app

Typical responsibilities include:
- Logging interfaces
- Time/date abstractions
- Result and error modeling
- Shared constants
- Shared value objects
- Low-level helpers with no business meaning

---

###### 3.1.1.1.1 Cross-Cutting Concerns

Cross-cutting concerns are concerns that affect multiple parts of the application and should not belong to any single feature.

Examples (conceptual, not exhaustive):
- Logging
- Time access
- Serialization helpers
- Error modeling
- Environment configuration
- Identifiers and shared types

Rules:
- Must not reference feature code
- Must be deterministic and side-effect–controlled
- Should expose interfaces rather than concrete implementations when possible
- Should be usable in tests without Flutter bindings

Assumptions:
- Cross-cutting utilities are pure Dart where possible.
- Flutter-specific dependencies are avoided in `core/`.

Open questions:
- Should `core/` be split further into submodules (e.g., `core/logging`, `core/time`)?
	- Yes
- Should enforcement be automated via lint rules or folder-level checks?
	- Yes

---

##### 3.1.1.2 `features/`

The `features/` directory contains all user-facing and domain-specific functionality.

Each feature is isolated and owns:
- Its state
- Its models
- Its logic
- Its UI
- Its internal utilities

Features must not depend on one another directly.

---

###### 3.1.1.2.1 Feature Isolation Rules

Each feature:
- Lives in its own directory under `lib/features/`
- Does not import from sibling feature directories
- Communicates only through:
  - Shared contracts in `core/`
  - Explicit dependency injection
- Can be removed without breaking unrelated features

Recommended internal structure per feature (example):
- features/<feature_name>/
- data/
- domain/
- presentation/
- state/
- widgets/

Rules:
- Feature-local helpers must not be promoted to `core/` unless reused by multiple features
- Shared behavior should be abstracted upward, not copied
- Feature code should assume other features do not exist

Assumptions:
- Riverpod is used to manage feature-level state (documented elsewhere)
- Each feature exposes its public API explicitly

Open questions:
- Should feature boundaries be enforced via package structure or lint rules?
	- Whichever is easier to implement
- Should features expose a single public entry file?
	- Unsure what this is asking

---

### 3.2 Feature-Based Architecture

The project uses a feature-based architecture rather than a layer-only architecture.

Each feature encapsulates:
- Data access
- Business rules
- State
- UI wiring

This reduces cross-feature coupling and improves testability.

---

#### 3.2.1 Feature Boundaries

A feature boundary defines what a feature owns and what it may access.

Boundaries enforce:
- Clear ownership of logic
- Predictable dependency direction
- Easier refactoring and removal

A feature may:
- Import from `core/`
- Import Dart and Flutter SDK libraries
- Use dependency injection to receive shared services

A feature may not:
- Import another feature directly
- Reach into another feature’s internal folders
- Share mutable global state

Assumptions:
- Features communicate indirectly through shared abstractions or events.
- Cross-feature coordination is minimal and explicit.

Open questions:
- Will any “orchestration” layer exist above features?
	- Most likely
- Should cross-feature communication use events, services, or callbacks?
	- Follow best practice

---

### 3.3 Dependency Direction

Dependency direction is strictly enforced to avoid cyclic or hidden coupling.

Allowed dependency flow
	- core  ←  features
Never:
	- features → features
	- core → features

---

#### 3.3.1 Allowed Dependencies

| Source     | Can depend on |
|------------|----------------|
| core       | Dart SDK only |
| features   | core, Dart SDK, Flutter SDK |
| main/app   | core, features |

Additional rules:
- Dependency inversion should be preferred when behavior varies
- Shared abstractions live in `core`
- Concrete implementations live in features or app wiring

Assumptions:
- Dependency injection is used to bind implementations at runtime
- Static globals are avoided where possible

Open questions:
- Is a DI container being used explicitly (e.g., Riverpod providers)?
- Should feature registration be centralized?

---

### 3.4 Shared Utilities

Shared utilities live under `core/` and must follow strict constraints:
- Deterministic behavior
- No feature awareness
- Minimal side effects
- Clear contracts

---

#### 3.4.1 Logging

Purpose:
Provide a consistent, centralized logging abstraction usable across all layers.

Responsibilities:
- Define logging interfaces or helpers
- Normalize log levels
- Provide structured log output
- Avoid direct coupling to a logging backend

Typical capabilities:
- Debug / info / warning / error levels
- Tagged or scoped logs
- Optional structured metadata

Constraints:
- Must not depend on feature code
- Must be safe to call from anywhere
- Should support replacement or redirection of output

Assumptions:
- A logging abstraction exists or will exist in `core`
- Actual output targets (console, file, remote) are configured elsewhere

Open questions:
- Is logging synchronous or buffered?
	- Synchronous
- Should logs be persisted locally?
	- No
- Are logs user-visible or developer-only?
	- Only in development

---

#### 3.4.2 Time & Date Handling

Purpose:
Provide a single, controlled source of time-related behavior.

Responsibilities:
- Access to “current time”
- Date/time parsing and formatting
- Duration helpers
- Relative time calculations

Rules:
- Application code must not call `DateTime.now()` directly
- Time access must go through a shared abstraction
- All time values should be explicit and testable

Typical patterns:
- `TimeProvider` or similar abstraction
- Injectable clock for testing
- Explicit UTC handling

Constraints:
- Must be deterministic under test
- Must support serialization safely
- Must avoid implicit timezone behavior

Assumptions:
- Internal time representation is UTC
- Formatting is handled at presentation boundaries

Open questions:
- Should time be injectable at the provider level?
- Should historical data ever be reinterpreted under different timezones?
	- We should convert UTC times to reflect whatever time zone the user is in when viewing the data
- Should monotonic time be supported for duration measurement?
	- Yes

---

### 3.5 Summary Constraints

- `core/` must remain dependency-free from features
- Features must be isolated and self-contained
- Communication occurs through explicit contracts
- Utilities must be deterministic and reusable
- Architecture prioritizes clarity and explicitness over convenience 


---
