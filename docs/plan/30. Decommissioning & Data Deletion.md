## 30. Decommissioning & Data Deletion

### 30.0 Scope and Definitions

**Decommissioning** in AshTrail covers:
- Removing an account from the app (local-only).
- Deleting remote data tied to an account (remote).
- Clearing subsets of data (partial resets) without removing the account.

**Key terms**
- **Account**: A logical identity within AshTrail (may correspond to a Firebase Auth user, a local profile, or both).
- **Local data**: On-device database records, caches, preferences, derived analytics, and any stored credentials/tokens.
- **Remote data**: Backend-stored records (e.g., Firestore documents, Cloud Storage objects, server-side token state).
- **Tombstone**: A persisted marker indicating deletion (used for sync consistency).

> Assumption: AshTrail is offline-first and supports multiple accounts on a single device (based on prior docs).  
> Open question: What is the definitive source of truth for “Account” (purely local vs Firebase Auth-backed)?

---

### 30.1 Account Deletion

#### 30.1.1 Overview

Account deletion is the user-initiated process to remove an account and its data from AshTrail.

Two levels may exist:
- **Local-only delete**: Removes the account and all related data from the device.
- **Full delete (local + remote)**: Also deletes remote data associated with the account.

> Open question: Does the product currently expose both options, or only local removal?

---

### 30.1.2 Responsibilities

**UI / UX**
- Provide a clear entry point (e.g., Settings → Account → Delete).
- Display explicit warnings about irreversibility (see §30.3).
- Support a “local-only” vs “local + remote” choice if remote deletion exists.

**Domain / Application Layer**
- Ensure deletion is account-scoped (never affects other accounts on the same device).
- Ensure deletion is idempotent (safe to retry).
- Coordinate local cleanup steps in correct order.
- For remote deletion: initiate, track status, and reconcile offline behavior.

**Data Layer**
- Local database: perform scoped deletion by `accountId`.
- Secure storage: remove secrets/tokens for `accountId`.
- Cache layers: clear derived/aggregated views tied to `accountId`.
- Notification scheduling: cancel pending notifications for `accountId`.

**Sync / Remote**
- If remote deletion exists, enforce authorization and correctness:
  - Only the authenticated user (or privileged backend) can delete their dataset.
  - Prevent resurrection of deleted data from pending sync queues.

---

#### 30.1.3 Data Structures (conceptual)

> Note: Exact types/locations must be confirmed from implementation.

Minimum recommended internal models:

- **DeletionRequest**
  - `accountId: string` (required)
  - `scope: enum[localOnly, localAndRemote]` (required)
  - `requestedAt: datetime` (required)
  - `reason: string?` (optional; analytics/debug only)
  - `clientOperationId: string` (required; idempotency key)

- **DeletionState**
  - `phase: enum[idle, localInProgress, remoteInProgress, completed, failed]`
  - `lastError: string?`
  - `retryable: bool`

- **DeletionTombstone** (only if deletion must sync)
  - `accountId: string`
  - `deletedAt: datetime`
  - `clientOperationId: string`
  - `remoteAckAt: datetime?`

> Open questions:
> - Is there an existing “operation log” / outbox table for sync? If yes, deletion should be represented as an operation.
> - Is there a dedicated per-account “meta” doc/record suitable for a tombstone?

---

### 30.1.4 State & Flow

#### A) Local-only deletion flow

1. **User action**
   - User chooses “Delete account from this device” (local-only).
2. **Pre-flight**
   - Confirm the account exists locally.
   - Block concurrent operations for the account (e.g., sync, imports, edits).
3. **Stop background work**
   - Pause/cancel active sync for that account.
   - Cancel scheduled notifications for that account.
4. **Delete local data**
   - Delete all account-scoped entities (logs, settings, derived analytics, drafts, queued operations).
5. **Clear secrets**
   - Remove tokens, refresh secrets, cached auth state, encryption keys for the account (if per-account).
6. **Remove account from account registry**
   - Remove account entry from “known accounts” list.
7. **Finalize**
   - UI navigates away (e.g., to account picker).
   - App state is refreshed to ensure no providers are holding stale references.

**Post-condition**
- No local data remains that can identify the deleted account or restore its state.

#### B) Local + remote deletion flow (if supported)

1–4. Same as local-only, plus:
5. **Issue remote deletion**
   - Either:
     - Client requests deletion via a privileged backend endpoint (recommended), or
     - Client performs deletions directly (only feasible if security rules allow safe recursive deletes).
6. **Remote acknowledgement**
   - Confirm completion via backend response or state polling.
7. **Prevent resurrection**
   - Ensure no queued sync operations can re-upload old data:
     - Clear outbox before remote delete request, or
     - Write tombstone first and reject uploads server-side.

**Offline behavior**
- If offline, remote deletion cannot complete immediately.
- Recommended: treat as **two-step**:
  - Perform local deletion immediately.
  - Record a pending remote deletion intent (tombstone/outbox) to be sent when back online.

> Open questions (must be answered to finalize implementation-accurate docs):
> - Does AshTrail have a backend service capable of deleting Firestore collections recursively?
> - Is there a Cloud Function or API already used for privileged operations (e.g., token refresh system suggests some backend exists)?
> - What is the remote data model (collection paths) that must be deleted?

---

### 30.1.5 Edge Cases & Failure Modes

**Local cleanup partially fails**
- Example: DB write lock, corrupted storage, permission error.
- Required behavior:
  - Mark deletion as `failed` with actionable error.
  - Provide retry.
  - Ensure partially deleted account is not “usable” until repaired or fully removed.

**Concurrent operations**
- Sync running while deletion begins.
- Required behavior:
  - Mutual exclusion: a per-account lock or “maintenance mode” gate.
  - Stop-the-world for that account before destructive operations.

**Remote deletion fails after local deletion**
- User sees local account gone, but remote data remains.
- Options:
  - Show a “remote deletion pending/failed” status in a global diagnostics screen.
  - Provide a way to retry remote deletion (requires auth context; see below).

**Auth context lost**
- If remote deletion requires being signed in, but user removed auth state locally first.
- Required behavior:
  - Ensure remote delete is requested **before** wiping auth, or
  - Require the user to re-authenticate specifically to complete remote deletion.

**Multi-device**
- If the same account exists on another device:
  - Remote deletion should propagate (other device must observe the deletion and purge local state).
  - If remote deletion is not supported, local-only deletion should be clearly labeled as device-specific.

---

### 30.2 Partial Resets

#### 30.2.1 Overview

Partial resets remove subsets of data while keeping the account itself present and usable.

Common reset scopes:
- **Per-account wipe (data)**: Remove logs/entries and derived analytics for the selected account.
- **Per-account settings reset**: Restore defaults for that account’s preferences.
- **Cache-only clear**: Remove derived/temporary data without deleting primary logs.

> Open question: Which of these scopes are actually implemented/exposed in the UI?

---

#### 30.2.2 Responsibilities

- Provide explicit scope selection and preview of what will be deleted.
- Ensure reset is account-scoped.
- Ensure reset is idempotent and safe to retry.
- Decide how reset interacts with remote sync:
  - Local-only reset vs synced deletion of remote logs.

---

#### 30.2.3 Data Structures (conceptual)

- **ResetRequest**
  - `accountId: string` (required)
  - `scope: enum[logsOnly, settingsOnly, cachesOnly, everythingButAccount]` (required)
  - `requestedAt: datetime` (required)
  - `clientOperationId: string` (required)

> Open question: Is there an existing “settings version” mechanism? If so, resets should bump a version.

---

#### 30.2.4 State & Flow: Per-Account Wipe

1. User selects account → chooses reset scope.
2. Pre-flight:
   - Stop per-account sync + background operations.
3. Execute scoped deletion:
   - Logs: delete all entities keyed by `accountId`.
   - Derived analytics: delete computed aggregates/histograms for `accountId`.
   - Caches: clear in-memory + persisted caches.
4. Post:
   - Recompute derived data as needed (or lazily on next view).
   - Resume sync if applicable.

**Remote sync considerations**
- If the wipe is intended to delete remote logs too:
  - Represent as a synced operation (outbox) or a backend “wipe account data” request.
  - Ensure other devices also purge via tombstone/version gating.

---

### 30.3 Irreversibility Guarantees

#### 30.3.1 Overview

AshTrail must treat deletion and destructive resets as irreversible from the user’s perspective.

**Guarantee definition**
- After a successful operation:
  - Deleted local data cannot be restored by the app.
  - If remote deletion exists and completes, remote data cannot be restored by the app.

> Important distinction: If OS-level backups (iCloud/Google) exist, those can reintroduce data unless explicitly addressed.  
> Open question: Does AshTrail opt-out of backups for local databases / secure data?

---

#### 30.3.2 User Warnings

Minimum required warnings (wording may vary; meaning must not):
- “This deletes data permanently.”
- “This cannot be undone.”
- If local-only: “This only removes data from this device.”
- If remote: “This deletes data from the server and all devices.”

Recommended safety UX:
- Require explicit confirmation step:
  - Checkbox + “Delete” button enabled only after acknowledgement, or
  - Require typing a confirmation string (e.g., `DELETE`) for full deletion.
- Show what will be deleted:
  - Count of logs/entries (if cheap to compute).
  - Date range of data affected (optional).
- Show what will remain (for partial resets).

---

#### 30.3.3 Edge Cases & Failure Modes

**User cancels mid-flow**
- If cancellation occurs after local deletion started:
  - Operation should continue to completion (don’t leave a half-deleted zombie account).
  - UI should reflect “in progress” until done.

**Unexpected app termination**
- If the app is killed mid-delete:
  - On next startup, detect incomplete delete and resume/finish.
  - Requires durable “DeletionState” persisted before starting destructive steps.

**Remote eventual consistency**
- If remote deletion is asynchronous:
  - UI should state: “Remote deletion pending.”
  - Provide status + retry path.

---

### 30.4 Future Extensions (clearly labeled)

- **Backend-driven deletion**
  - Add a privileged API endpoint for:
    - Recursive Firestore deletes
    - Storage object deletes
    - Token/session invalidation
- **Deletion tombstones + sync propagation**
  - Allow other devices to detect deletion and self-purge.
- **Data retention window**
  - Optional “cooldown” for accidental deletes (soft-delete with retention), if product requirements allow.
  - Would require careful UX to avoid contradicting “irreversible” messaging.
- **Export-before-delete**
  - Offer export flow (CSV/JSON) immediately before deletion or reset.
- **Compliance mode**
  - Add explicit guarantees/logs for “right to be forgotten” style requirements if needed.

---

### 30.5 Open Questions (must be answered to finalize implementation-accurate docs)

1. Does AshTrail currently support **remote** deletion, or only local removal?
2. What is the **remote datastore** (Firestore paths, Storage buckets) for account-scoped data?
3. Is there a **backend service** (Cloud Functions/API) capable of privileged deletes?
4. Is there an **outbox/operation log** pattern used for sync, and can deletion be represented as an operation?
5. Where are per-account secrets stored (secure storage keying scheme), and are there per-account encryption keys?
6. Does the app opt-out of OS backups for local DB files (to prevent “deleted data reappearing”)?
