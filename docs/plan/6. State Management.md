## 6. State Management

### Overview
State management in AshTrail coordinates application lifecycle, account context, logging workflows, synchronization, and error handling. It is designed to support:
- Multi-account usage
- Offline-first operation
- Predictable, recoverable state transitions
- Explicit separation between transient UI state and persisted domain state

State is primarily managed using Riverpod providers, with clear ownership boundaries between global, account-scoped, and feature-specific state.

---

### Responsibilities
- Initialize application dependencies and determine startup flow
- Track and switch active accounts
- Manage in-progress and persisted log entries
- Coordinate local vs remote (Firestore) synchronization
- Surface recoverable and fatal errors consistently

---

### 6.1 Global State

#### 6.1.1 App Initialization State

#### App Initialization Overview
Represents the app-wide startup lifecycle before user interaction is possible.

#### App Initialization Responsibilities
- Load core services (storage, sync engine, config)
- Determine authentication and account availability
- Gate navigation until initialization completes

#### App Initialization Data Structures
| Field | Type | Description |
|-----|-----|------------|
| `status` | enum | `uninitialized`, `initializing`, `ready`, `failed` |
| `error` | Error? | Initialization failure details |

#### App Initialization State Flow
1. App launch triggers `initializing`
2. Core dependencies are constructed
3. Local persistence is checked
4. App transitions to `ready` or `failed`

#### App Initialization Edge Cases & Failure Modes
- Corrupted local storage
- Missing required configuration
- Partial initialization success

#### App Initialization Assumptions
- Initialization runs exactly once per app launch
- No user interaction before `ready`

#### App Initialization Open Questions
- Should initialization be retryable without app restart?
	- Yes, if we retry transition from the loading screen to a message letting the user know and if it fails again says itâ€™s having issues right now check for updates or try again later

---

### 6.2 Account State

#### 6.2.1 Active Account Selection

#### Active Account Selection Overview
Tracks which account is currently active and scopes all logging and analytics operations.

#### Active Account Selection Responsibilities
- Store active account ID
- Trigger downstream state resets on account switch

#### Active Account Selection Data Structures
| Field               | Type    | Description                |
| ------------------- | ------- | -------------------------- |
| `activeAccountId`   | string  | Currently selected account |
| `availableAccounts` | List<?> | Locally known accounts     |


#### Active Account Selection State Flow
- On app start, last-used account is restored if available
- Changing the active account invalidates:
  - Logging draft state
  - Account-scoped caches
  - Sync queues

#### Active Account Selection Edge Cases & Failure Modes
- Active account deleted locally
- Account exists locally but not remotely

#### Active Account Selection Assumptions
- Exactly one active account at a time

---

### 6.3 Logging State

#### 6.3.1 Draft State

#### Draft State Overview
Represents in-progress, unsaved log entries.

#### Draft State Responsibilities
- Hold temporary user input
- Support partial completion and cancellation
- Validate inputs before persistence

#### Draft State Data Structures
| Field | Type | Description |
|-----|-----|------------|
| `draftId` | string | Ephemeral identifier |
| `fields` | map | Input values by field |
| `isValid` | bool | Validation result |

#### Draft State Flow
- Draft is created on log start
- Updated on each input change
- Discarded on cancel or successful save

#### Draft State Edge Cases & Failure Modes
- App backgrounded mid-draft
- Account switch with active draft

#### Draft State Assumptions
- Draft state is never persisted automatically

---

### 6.3.2 Persisted State

#### Persisted State Overview
Represents saved log entries stored locally and optionally synced remotely.

#### Persisted State Responsibilities
- Provide immutable access to saved logs
- Serve as the source of truth for analytics

#### Persisted State Data Structures
| Field | Type | Description |
|-----|-----|------------|
| `logId` | string | Stable identifier |
| `timestamp` | DateTime | Log time |
| `data` | map | Structured log payload |
| `syncStatus` | enum | `local`, `pending`, `synced`, `conflict` |

#### Persisted State Flow
- Draft transitions to persisted on save
- Persisted logs enter sync pipeline

---

### 6.4 Sync State

#### 6.4.1 Pending Changes

#### Pending Changes Overview
Tracks local changes awaiting remote synchronization.

#### Pending Changes Responsibilities
- Queue unsynced operations
- Retry failed sync attempts

#### Pending Changes Data Structures
| Field | Type | Description |
|-----|-----|------------|
| `pendingLogs` | List<logId> | Logs awaiting sync |
| `lastAttempt` | DateTime? | Last sync attempt |

#### Pending Changes State Flow
- New persisted logs are marked `pending`
- Sync engine processes queue when online

#### Pending Changes Edge Cases & Failure Modes
- Large offline backlog
- Repeated transient network failures

---

### 6.4.2 Conflict State

#### Conflict State Overview
Represents detected divergence between local and remote data.

#### Conflict State Responsibilities
- Surface conflicts to resolution logic
- Prevent silent overwrites

#### Conflict State Data Structures
| Field | Type | Description |
|-----|-----|------------|
| `conflictingLogId` | string | Affected log |
| `localVersion` | LogEntry | Local data |
| `remoteVersion` | LogEntry | Remote data |

#### Conflict State Assumptions
- Conflicts are rare and explicit

#### Open Questions
- Will conflict resolution be automatic or user-driven?

---

### 6.5 Error State

#### 6.5.1 Recoverable Errors

#### Recoverable Errors Overview
Errors that allow continued app operation.

#### Recoverable Errors Responsibilities
- Inform the user
- Allow retry or graceful degradation

#### Recoverable Errors Examples
- Network unavailable
- Temporary sync failure
- Validation errors

---

### 6.5.2 Fatal Errors

#### Fatal Errors Overview
Errors that prevent safe continuation.

#### Fatal Errors Responsibilities
- Halt affected flows
- Provide diagnostic context

#### Fatal Errors Examples
- Unrecoverable data corruption
- Initialization failure

#### Fatal Errors Assumptions
- Fatal errors require app restart or reinstall

---

### Future Extensions
- Time-travel debugging for state transitions
- Per-account error isolation
- Background sync progress state
- Formal state machine definitions for critical flows

---
