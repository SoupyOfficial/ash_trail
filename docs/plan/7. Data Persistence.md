## 7. Data Persistence
### 7.1 Local Database (Hive)
#### 7.1.1 Overview
The local database is the system of record for AshTrail during normal operation.
- Enables offline-first behavior
- Guarantees durability of user-entered data
- Acts as the staging layer for sync to Firestore
- Must always be writable, regardless of network state

Hive is used due to:
- Low overhead
- Strong Flutter integration
- Predictable key–value semantics
- No background services or migrations required 

---
#### 7.1.1 Collections
Hive boxes are treated conceptually as collections.
##### 7.1.1.1 Log Records
Stores all log entries created by the user.

**Responsibilities**
- Persist every log entry immediately on creation
- Maintain authoritative local history
- Track sync state per record

**Fields**

| Field            | Type                 | Constraints                    |
| ---------------- | -------------------- | ------------------------------ |
| id               | String               | Unique, immutable              |
| accountId        | String               | Required                       |
| timestamp        | DateTime             | UTC, immutable                 |
| type             | enum                 | Must match supported log types |
| payload          | Map<String, dynamic> | Type-specific                  |
| createdAt        | DateTime             | UTC                            |
| updatedAt        | DateTime             | UTC                            |
| syncStatus       | enum                 | `pending`, `synced`, `error`   |
| lastSyncAttempt  | DateTime?            | Nullable                       |

**Assumptions**
- IDs are generated locally and reused for Firestore documents
- Timestamps are never mutated after creation 

---
##### 7.1.1.2 Accounts
Stores local account metadata.

**Responsibilities**
- Support multi-account switching
- Cache minimal account identity and state
- Avoid remote dependency for account selection

**Fields**

| Field        | Type     | Constraints      |
| ------------ | -------- | ---------------- |
| accountId    | String   | Primary key      |
| displayName  | String   | Required         |
| createdAt    | DateTime | UTC              |
| isActive     | bool     | Exactly one true |
**Assumptions**
- Authentication is handled elsewhere
- Accounts may exist locally before remote sync

---
#### 7.1.2 Indexing Strategy

Hive does not provide secondary indexes. Indexing is handled manually.

**Strategies**
- Primary key lookup by `id`
- In-memory filtered views via Riverpod
- Time-based queries performed by sorting cached lists  

**Constraints**
- No compound queries at the persistence layer
- All derived views are computed, not stored  

**Open Questions**
- Is Hive sufficient long-term for large datasets?
- Should log partitioning be introduced by date?  

---
### 7.2 Remote Database (Firestore)
#### 7.2.1 Overview
Firestore serves as:
- Cross-device sync target
- Backup and recovery layer
- Optional analytics source

Firestore is not considered authoritative during active sessions.

---
#### 7.2.1 Collection Structure
##### 7.2.1.1 Per-Account Namespacing
Data is namespaced per account to avoid cross-contamination.

**Structure**

accounts/{accountId}
└── logs/{logId}

**Rules**
- No global log collections
- Account ID is always embedded in the path
- Security rules enforce account isolation
---
#### 7.2.2 Document Shapes

Firestore documents mirror Hive records closely.

**Log Document Fields**

| Field       | Type      | Notes            |
| ----------- | --------- | ---------------- |
| id          | String    | Matches local ID |
| timestamp   | Timestamp | UTC              |
| type        | String    | Enum string      |
| payload     | Map       | Serialized       |
| createdAt   | Timestamp |                  |
| updatedAt   | Timestamp |                  |

**Constraints**
- No server-generated IDs
- No server timestamps required for correctness

**Assumptions**
- Client clocks are reasonably accurate
- Firestore is used in a single-region configuration

---

### 7.3 Sync Strategy
#### 7.3.1 Push Model
Local → Remote sync is the primary direction.

**Flow**
1. Observe locally `pending` records
2. Serialize and write to Firestore
3. On success:
   - Mark record as `synced`
   - Update `lastSyncAttempt`
1. On failure:
   - Mark record as `error`

**Rules**
- Never block UI on sync
- Never delete local data after sync 

---
#### 7.3.2 Pull Model
Remote → Local sync is secondary and explicit.

**Use Cases**
- New device
- Manual refresh
- Account recovery  

**Flow**
1. Fetch all remote logs for account
2. Compare by `id`
3. Insert missing local records only

**Constraints**
- No overwrite of existing local records
- No bidirectional merging  

**Assumptions**

- Local data is always newer or authoritative

  

---
#### 7.3.3 Conflict Resolution

Conflicts are resolved deterministically

**Rules**
- Local wins over remote
- Duplicate IDs are ignored
- No field-level merges

**Rationale**
- Logs are append-only
- Mutations are rare and controlled
- Simplicity over eventual consistency

**Open Questions**
- Should edits to existing logs be supported later?
- Is a tombstone mechanism required? 

---
### 7.4 Failure Modes
#### 7.4.1 Network Loss

**Behavior**
- All writes remain local
- Sync retries are deferred
- UI reflects unsynced state only via metadata

**Guarantees**
- No data loss
- No user action required to recover

---
#### 7.4.2 Partial Writes

**Scenarios**
- Firestore write succeeds but local update fails
- Local update succeeds but Firestore write fails
  
**Handling**
- Local state is always treated as source of truth
- Firestore inconsistencies are resolved on next push
- Duplicate writes are idempotent by ID  

**Assumptions**
- Firestore writes are atomic per document
- Network failures are transient
  
---
### 7.5 Future Extensions

**Clearly Out of Scope**
- Real-time listeners
- Multi-user collaboration
- Server-side aggregation

**Possible Extensions**
- Incremental pull with checkpoints
- Soft-delete and edit support
- Background sync with OS scheduling

---
