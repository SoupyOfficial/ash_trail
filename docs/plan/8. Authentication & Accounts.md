## 8. Authentication & Accounts

### 8.1 Overview

This section documents how authentication and account identity are handled in AshTrail, including login, logout, account switching, and the distinction between anonymous and authenticated usage.

Authentication exists to:
- Associate log data with a persistent identity
- Support multi-account usage on a single device
- Enable future sync and cross-device continuity
- Preserve offline-first behavior without blocking usage

AshTrail is designed to function without authentication, with auth treated as an optional capability layer rather than a hard requirement.

---

### 8.2 Responsibilities

Authentication and account handling are responsible for:
- Managing user authentication state (authenticated vs anonymous)
- Tracking the currently active account
- Enforcing session reset rules on account changes
- Determining data ownership and visibility
- Handling transitions between anonymous and authenticated states
- Preventing cross-account data leakage

Out of scope:
- Password management UI
- Advanced security features (e.g., MFA)
- Server-side auth enforcement details (unless explicitly implemented)

---

### 8.3 Auth Flow

#### 8.3.1 Login

##### Purpose

- Establish an authenticated identity
- Bind the current session to an account

##### High-level flow

1. User initiates login action
2. Authentication provider returns a user identity
3. App resolves or creates a corresponding local Account record
4. Active account state is updated
5. Session-scoped state is reset according to rules

##### Key behaviors

- Login does not implicitly delete local data
- Login may trigger data migration from anonymous state (see 8.5)
- Login must be safe to perform while offline (graceful failure)

##### Assumptions

- Authentication provider SDK handles credential validation
- A unique, stable user identifier is available post-login

##### Open questions

- Is login allowed while offline using cached credentials?
- Are multiple auth providers supported or planned?

---

#### 8.3.2 Logout

##### Purpose

- Remove authenticated context
- Return the app to an unauthenticated (anonymous) state

##### High-level flow

1. User initiates logout
2. Authentication tokens are cleared
3. Active account is unset or replaced with an anonymous account
4. Session-scoped state is reset

##### Key behaviors

- Local data is not deleted on logout
- Logout must not block access to existing local logs
- UI should immediately reflect unauthenticated state

##### Assumptions

- Anonymous usage is always permitted
- Logout does not require network access

---

### 8.4 Account Switching

Account switching allows multiple logical accounts to exist on a single device, regardless of authentication state. The implementation uses **Firebase Custom Tokens** to enable seamless switching without requiring user re-authentication.

#### 8.4.1 Seamless Multi-Account Architecture

##### Overview

The app supports multiple authenticated accounts simultaneously, with instant switching between them using Firebase Custom Tokens generated via a Cloud Function. See [Multi-Account Architecture Documentation](../MULTI_ACCOUNT_ARCHITECTURE.md) for complete implementation details.

##### Key Components

1. **TokenService** - Generates custom tokens via Cloud Function
2. **AccountSessionManager** - Stores and manages tokens with expiration
3. **Account Integration Service** - Generates tokens on initial sign-in
4. **Account Switcher** - Uses `signInWithCustomToken()` for instant switching

##### Data Isolation

- **Sync Filtering**: Only syncs records for the authenticated Firebase user
- **Query Filtering**: All data queries filter by active account's `userId`
- **Security**: Firestore rules enforce `request.auth.uid == accountId`

#### 8.4.2 Session Reset Rules

When the active account changes (login, logout, or manual switch):

##### Must reset

- In-memory session state
- Active filters and views
- Draft or unsaved log entries
- Any account-scoped caches

##### Must not reset

- Persistent local storage
- Other accounts’ data
- Global app configuration unrelated to account identity

##### Invariant

- At no point should data from one account be visible under another account context

##### Assumptions
- Each log record is explicitly associated with an account ID
- State management enforces account boundaries

---

### 8.5 Anonymous vs Authenticated

AshTrail distinguishes between:
- **Anonymous accounts**: Local-only, no external identity
- **Authenticated accounts**: Backed by an auth provider identity

Anonymous usage is a first-class mode, not a temporary state.

#### 8.5.1 Data Migration Rules

##### Scenario: Anonymous → Authenticated

- Anonymous data may optionally be migrated to the authenticated account
- Migration must be explicit and deterministic
- No automatic merging without clear ownership rules

##### Scenario: Authenticated → Anonymous

- Authenticated data remains associated with its account
- Anonymous account starts with a clean logical state

##### Constraints

- Migration must be idempotent
- Partial migration must not corrupt source or destination data

##### Open questions

- Is migration user-controlled or automatic?
- Are conflicts possible if authenticated account already has data?
- Is rollback supported if migration fails?

---

### 8.6 Security Assumptions

#### 8.6.1 Trust Model

AshTrail operates under the following trust assumptions:

- The client device is trusted
- Local storage is not encrypted beyond platform defaults
- Authentication providers are trusted to validate identity
- No hostile multi-user device scenarios are assumed

##### Implications

- App is not hardened against a malicious local user
- Data separation is logical, not cryptographic
- Security is focused on correctness, not adversarial resistance

##### Non-goals

- Preventing rooted/jailbroken device access
- Protecting against local filesystem inspection
- Enterprise-grade threat models

---

### 8.7 Edge Cases & Failure Modes

- Login succeeds but account resolution fails
- Logout during an active log entry
- App restart mid-account switch
- Migration interrupted by app termination
- Auth provider returns inconsistent user identifiers

##### Expected handling

- Fail safe: preserve data, reset session, require user re-entry
- Never delete data automatically
- Prefer explicit recovery paths over silent fixes

---

### 8.8 Future Extensions

Potential future additions (not currently implemented):

- Cross-device sync enforcement rules
- Account-level encryption keys
- Multiple authenticated accounts per provider
- Role-based access or shared accounts
- Explicit migration UI with preview and rollback

All future extensions must preserve:
- Offline-first usability
- Clear account boundaries
- Non-destructive behavior by default

---
