## 9. UI Architecture

### Overview
The UI Architecture defines how screens, navigation, widgets, and forms are structured and composed in AshTrail.  
Its primary goals are:

- Predictable navigation across core workflows
- Clear separation between UI, state, and domain logic
- Reusable, testable widgets
- Accessibility and platform-consistent behavior

This layer consumes state from Riverpod providers and emits user intent events. It must not contain business logic.

---

### Responsibilities
- Define navigation structure and routes
- Render screens based on application and account state
- Collect user input and surface validation feedback
- Provide reusable UI components
- Ensure baseline accessibility support

---

### 9.1 Navigation

### Navigation Overview
Navigation coordinates movement between high-level screens such as logging, history, and analytics.  
Navigation must be state-aware (e.g., active account, initialization complete).

---

### Navigation Responsibilities
- Declare routes and route names
- Control screen transitions
- Prevent navigation into invalid app states

---

### 9.1.1 Route Definitions

#### Data Structures
Routes are defined as named paths mapped to screen widgets.

| Field | Type | Description |
|-----|-----|------------|
| routeName | string | Unique route identifier |
| builder | WidgetBuilder | Screen constructor |
| requiresAccount | bool | Whether an active account is required |

#### State & Flow
- App startup resolves initialization state
- If no account is active, navigation is restricted
- Route changes are triggered by user actions or state changes

#### Assumptions
- Routing is centralized (not defined per-feature)
- Deep linking is not currently required

#### Open Questions
- Is declarative routing (e.g., Router API) planned?
- Should routes encode account IDs explicitly?

---

### 9.2 Screens

### Screens Overview
Screens represent full-page UI surfaces.  
Each screen:
- Subscribes to relevant providers
- Delegates logic to controllers or services
- Renders composed widgets

---

### 9.2.1 Logging Screen

#### Logging Screen Interface

The logging screen provides two primary tabs:

1. **Detailed Entry Tab** (Default/Primary)
   - Full form with all optional fields
   - Press-and-hold button to record duration (recommended pattern)
   - Optional mood and physical ratings (default to null/"not set")
   - Optional reason, notes, and location fields
   - Supports automatic duration population from press-hold or manual input

2. **Backdate Tab** (Secondary)
   - Create log entries for past events (up to 30 days ago)
   - Same form as detailed entry with date/time picker
   - Quick preset buttons (30 mins ago, 1 hour ago, 2 hours ago, yesterday)
   - Marked with lower time confidence in timeline

#### Logging Screen Responsibilities

- Capture new log entries via detailed form
- Support duration recording via press-and-hold interaction
- Allow optional rating input (mood, physical)
- Display backdate dialog for past events
- Submit validated log data
- Provide clear feedback on submission success/failure

#### Duration Recording Pattern

The recommended pattern for quick duration logging:

- User fills optional form fields (event type, reason, notes, ratings)
- User presses and holds the duration button
- Duration counter updates in real-time
- User releases button to submit with recorded duration
- Form auto-populates duration field from recorded press-hold
- Minimum threshold: 1 second
- Maximum duration: 3600 seconds (1 hour)

#### Rating Behavior

Mood and physical rating fields:

- **Default state**: null (not set)
- **UI representation**: Slider from 1-10 (zero not available)
- **User action**: Slider interaction sets value
- **Reset**: Form reset clears all ratings back to null
- **Validation**: If provided, must be 1-10; null is always valid

#### Logging Screen State Flow

1. User navigates to Detailed Entry tab or Backdate tab
2. User fills optional form fields (event type, ratings, etc.)
3. For duration:
   - User can press-and-hold button to record duration, OR
   - User can manually enter duration value
4. User clicks "Log Event" button
5. Validation runs (1-10 for ratings if provided, location pair constraint, etc.)
6. Valid entries are persisted via LogRecordService
7. UI resets form and shows success feedback

#### Logging Screen Edge Cases

- Submission attempted with no active account
- Duration recorded less than 1 second (rejected with feedback)
- Manual duration input with invalid value
- Rating values outside 1-10 range (clamped to valid range)
- Backdated time more than 30 days in past (rejected)
- Both latitude and longitude must be present (one without other rejected)

---

### 9.2.2 History View

#### History View Responsibilities
- Display persisted log entries
- Support filtering and grouping by date, event type
- Reflect account-scoped data

#### History View Filtering & Grouping
Implemented filtering and grouping options:
- **Group by**: None, Day, Week, Month, Event Type
- **Filter by date range**: Select start and end dates
- **Filter by event type**: Choose specific activity types
- **Search**: Text search across notes/metadata

#### History View State Flow
- Subscribes to log history provider
- Reacts to account switch events
- Rebuilds on data sync or local mutation
- Updates group and filter selections

#### History View Edge Cases
- Empty history state
- Large datasets impacting scroll performance
- Logs created offline then synced

---

### 9.2.3 Analytics View

#### Analytics View Responsibilities
- Visualize aggregated log data
- React to time range and filter changes
- Display derived metrics only (no raw mutation)

#### Analytics View State Flow
- Reads pre-aggregated analytics state
- Triggers recomputation via state changes
- Renders charts and summaries

#### Analytics View Assumptions
- Analytics are read-only from the UI layer
- Heavy computation is not performed in widgets

---

### 9.3 Widgets

### Widgets Overview
Widgets are composable UI building blocks used across screens.

---

### 9.3.1 Reusable Components

#### Reusable Components Examples
- Labeled input rows
- Primary / secondary buttons
- Section headers
- Empty-state placeholders

#### Reusable Components Constraints
- Widgets must be stateless where possible
- Stateful widgets must not own business logic
- Styling is centralized via theme definitions

---

### 9.4 Forms

### Forms Overview
Forms handle structured user input and validation feedback.

---

### 9.4.1 Input Handling

#### Input Handling Responsibilities
- Maintain transient form state
- Normalize user input
- Emit submission intent

#### Input Handling State Flow
- Local form state tracks field values
- On change: update state only
- On submit: trigger validation pipeline

---

### 9.4.2 Validation Feedback

#### Validation Feedback Responsibilities
- Surface field-level errors
- Prevent invalid submission
- Display global submission failures

#### Validation Types
- Required fields
- Type constraints (number, duration)
- Cross-field dependencies

#### Validation Feedback Edge Cases
- Validation rules changing between app versions
- Legacy logs not matching new constraints

---

### 9.5 Accessibility Considerations

### Accessibility Overview
Accessibility ensures the app remains usable across devices and user settings.

---

### 9.5.1 Text Scaling

#### Text Scaling Responsibilities
- Respect system text scale factor
- Avoid clipped or overlapping text
- Maintain readable layouts at large sizes

#### Text Scaling Constraints
- No fixed-height text containers
- Layouts must reflow vertically

#### Text Scaling Open Questions
- Is screen reader (TalkBack / VoiceOver) support explicitly targeted?
- Are color-contrast audits planned?

---

### Future Extensions
- Declarative navigation with guarded routes
- Deep linking support
- Keyboard navigation for tablets and desktop
- Full screen reader semantics annotations

---
