#!/usr/bin/env python3
"""
Markdown Documentation Consolidator

This script can combine multiple numbered markdown files into a single
consolidated document, or split a consolidated document back into individual files.

Usage:
    python consolidate_docs.py combine [--output OUTPUT] [--input-dir INPUT_DIR]
    python consolidate_docs.py split [--input INPUT] [--output-dir OUTPUT_DIR]

Examples:
    # Combine all markdown files in current directory
    python consolidate_docs.py combine

    # Combine files from specific directory
    python consolidate_docs.py combine --input-dir ./docs/plan --output combined.md

    # Split consolidated file back into individual files
    python consolidate_docs.py split --input combined.md --output-dir ./output
"""

import argparse
import os
import re
from pathlib import Path
from typing import List, Tuple, Optional


class MarkdownConsolidator:
    """Handles combining and splitting markdown documentation files."""

    # Marker to indicate where each file starts in the consolidated document
    FILE_SEPARATOR = "\n---\n\n"
    FILE_HEADER = "<!-- FILE: {} -->\n\n"

    def __init__(self):
        self.file_pattern = re.compile(r'^(\d+)\.\s+(.+)\.md$')

    def get_markdown_files(self, directory: Path) -> List[Tuple[int, Path]]:
        """
        Get all numbered markdown files in the directory, sorted by number.

        Returns:
            List of tuples (number, filepath) sorted by number.
        """
        files = []

        for file in directory.glob('*.md'):
            match = self.file_pattern.match(file.name)
            if match:
                number = int(match.group(1))
                files.append((number, file))

        # Sort by the numeric prefix
        files.sort(key=lambda x: x[0])
        return files

    def generate_anchor(self, filename: str) -> str:
        """
        Generate a markdown anchor from a filename.
        
        Args:
            filename: The filename (e.g., "1. Project Overview.md")
            
        Returns:
            A markdown-compatible anchor (e.g., "1-project-overview")
        """
        # Remove .md extension
        name = filename.rsplit('.md', 1)[0]
        # Convert to lowercase and replace spaces/dots with hyphens
        anchor = name.lower().replace(' ', '-').replace('.', '')
        return anchor

    def convert_toc_links(self, content: str, files: List[Tuple[int, Path]]) -> str:
        """
        Convert wiki-style links [[...]] to markdown links in table of contents.
        
        Args:
            content: The content with wiki-style links
            files: List of (number, filepath) tuples for generating anchors
            
        Returns:
            Content with converted links
        """
        # Create a mapping of link text to anchors
        link_map = {}
        for number, filepath in files:
            # Match patterns like "1. Project Overview"
            link_text = filepath.name.rsplit('.md', 1)[0]
            anchor = self.generate_anchor(filepath.name)
            link_map[link_text] = anchor
        
        # Replace [[text]] with [text](#anchor)
        def replace_link(match):
            link_text = match.group(1)
            if link_text in link_map:
                return f"[{link_text}](#{link_map[link_text]})"
            return match.group(0)  # Return original if no match
        
        return re.sub(r'\[\[(.+?)\]\]', replace_link, content)

    def combine(self, input_dir: Path, output_file: Path) -> None:
        """
        Combine all numbered markdown files into a single consolidated file.

        Args:
            input_dir: Directory containing the markdown files
            output_file: Path to the output consolidated file
        """
        files = self.get_markdown_files(input_dir)

        if not files:
            print(f"No numbered markdown files found in {input_dir}")
            return

        print(f"Found {len(files)} markdown files to combine")

        # Check if first file is a table of contents
        has_toc = files and files[0][0] == 0 and 'table of contents' in files[0][1].name.lower()

        with open(output_file, 'w', encoding='utf-8') as outfile:
            # Write a header for the consolidated document
            outfile.write("# AshTrail - Consolidated Documentation\n\n")
            outfile.write("*This document was automatically generated by consolidating ")
            outfile.write(f"{len(files)} individual markdown files.*\n\n")
            outfile.write("---\n\n")

            for idx, (number, filepath) in enumerate(files):
                print(f"Processing: {filepath.name}")

                # Write file marker
                outfile.write(self.FILE_HEADER.format(filepath.name))
                
                # Add anchor for navigation
                anchor = self.generate_anchor(filepath.name)
                outfile.write(f'<a id="{anchor}"></a>\n\n')

                # Read and write file content
                with open(filepath, 'r', encoding='utf-8') as infile:
                    content = infile.read()
                    
                    # Convert wiki-style links to markdown links if this is the TOC
                    if has_toc and idx == 0:
                        content = self.convert_toc_links(content, files)
                        print("  → Converted table of contents links")
                    
                    outfile.write(content)

                # Add separator between files (except after the last file)
                if idx < len(files) - 1:
                    outfile.write(self.FILE_SEPARATOR)

        print(f"\n✓ Successfully combined {len(files)} files into {output_file}")
        print(f"  Total size: {output_file.stat().st_size:,} bytes")

    def split(self, input_file: Path, output_dir: Path) -> None:
        """
        Split a consolidated markdown file back into individual files.

        Args:
            input_file: Path to the consolidated markdown file
            output_dir: Directory where individual files will be created
        """
        if not input_file.exists():
            print(f"Error: Input file {input_file} does not exist")
            return

        # Create output directory if it doesn't exist
        output_dir.mkdir(parents=True, exist_ok=True)

        with open(input_file, 'r', encoding='utf-8') as infile:
            content = infile.read()

        # Find all file markers
        file_header_pattern = re.compile(r'<!-- FILE: (.+?) -->\n\n')
        markers = list(file_header_pattern.finditer(content))

        if not markers:
            print("Warning: No file markers found in the consolidated document")
            print("The document may not have been created by the combine function")
            return

        print(f"Found {len(markers)} file markers")

        # Extract and save each file
        for idx, match in enumerate(markers):
            filename = match.group(1)
            start_pos = match.end()
            
            # Skip the anchor tag if present (e.g., <a id="..."></a>)
            anchor_pattern = r'<a id="[^"]+"></a>\n\n'
            remaining_content = content[start_pos:]
            anchor_match = re.match(anchor_pattern, remaining_content)
            if anchor_match:
                start_pos += anchor_match.end()

            # Find the end position (start of next file or end of document)
            if idx < len(markers) - 1:
                end_pos = markers[idx + 1].start()
                # Remove the separator
                file_content = content[start_pos:end_pos].rstrip()
                # Remove trailing separator if present
                if file_content.endswith(self.FILE_SEPARATOR.strip()):
                    file_content = file_content[:-len(self.FILE_SEPARATOR.strip())].rstrip()
            else:
                file_content = content[start_pos:].rstrip()
            
            # Convert markdown links back to wiki-style for TOC
            if idx == 0 and 'table of contents' in filename.lower():
                # Convert [text](#anchor) back to [[text]]
                file_content = re.sub(r'\[([^\]]+)\]\(#[^\)]+\)', r'[[\1]]', file_content)

            output_path = output_dir / filename
            with open(output_path, 'w', encoding='utf-8') as outfile:
                outfile.write(file_content)
                outfile.write('\n')  # Ensure file ends with newline

            print(f"Created: {output_path.name}")

        print(f"\n✓ Successfully split into {len(markers)} files in {output_dir}")

    def preview_structure(self, directory: Path) -> None:
        """
        Preview the structure of markdown files that would be combined.

        Args:
            directory: Directory containing the markdown files
        """
        files = self.get_markdown_files(directory)

        if not files:
            print(f"No numbered markdown files found in {directory}")
            return

        print(f"\nFound {len(files)} markdown files:\n")
        total_size = 0

        for number, filepath in files:
            size = filepath.stat().st_size
            total_size += size
            print(f"  {number:2d}. {filepath.name:<50} ({size:>8,} bytes)")

        print(f"\n  Total size: {total_size:,} bytes")
        print(f"  Files: {len(files)}")


def main():
    parser = argparse.ArgumentParser(
        description='Combine or split markdown documentation files',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    subparsers = parser.add_subparsers(dest='command', help='Command to execute')

    # Combine command
    combine_parser = subparsers.add_parser(
        'combine',
        help='Combine numbered markdown files into a single file'
    )
    combine_parser.add_argument(
        '--input-dir',
        type=Path,
        default=Path('.'),
        help='Directory containing markdown files (default: current directory)'
    )
    combine_parser.add_argument(
        '--output',
        type=Path,
        default=Path('consolidated.md'),
        help='Output file path (default: consolidated.md)'
    )

    # Split command
    split_parser = subparsers.add_parser(
        'split',
        help='Split consolidated markdown file into individual files'
    )
    split_parser.add_argument(
        '--input',
        type=Path,
        default=Path('consolidated.md'),
        help='Input consolidated file (default: consolidated.md)'
    )
    split_parser.add_argument(
        '--output-dir',
        type=Path,
        default=Path('split_output'),
        help='Output directory for split files (default: split_output)'
    )

    # Preview command
    preview_parser = subparsers.add_parser(
        'preview',
        help='Preview the structure of markdown files'
    )
    preview_parser.add_argument(
        '--input-dir',
        type=Path,
        default=Path('.'),
        help='Directory containing markdown files (default: current directory)'
    )

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    consolidator = MarkdownConsolidator()

    if args.command == 'combine':
        consolidator.combine(args.input_dir, args.output)
    elif args.command == 'split':
        consolidator.split(args.input, args.output_dir)
    elif args.command == 'preview':
        consolidator.preview_structure(args.input_dir)


if __name__ == '__main__':
    main()
