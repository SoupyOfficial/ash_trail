## 18. Data Integrity & Consistency

### Overview
This section defines how AshTrail preserves correctness, prevents corruption, and maintains consistent behavior across local and remote data stores. It exists to ensure that user logs remain accurate, non-duplicated, and recoverable under offline-first and eventual-consistency constraints.

---

### 18.1 Source of Truth

### Overview
Defines which data store is authoritative in different operating modes (offline vs online) and how conflicts are resolved.

### Responsibilities
- Establish clear authority boundaries between local storage and remote sync targets.
- Prevent accidental overwrites during synchronization.
- Ensure deterministic conflict resolution.

### 18.1.1 Local vs Remote Authority

#### Rules
- **Local database is the primary source of truth**
  - All user actions write to local storage first.
  - UI always reflects local state.
- **Remote storage is a replication target**
  - Used for backup, cross-device continuity, and analytics.
  - Never blocks local writes.

#### Conflict Resolution
- Conflicts are resolved in favor of **local state** unless explicitly overridden.
- Remote data is treated as:
  - Stale
  - Incomplete
  - Potentially conflicting

#### Assumptions
- The user may operate fully offline for extended periods.
- Remote writes may fail or be delayed without user awareness.

#### Open Questions
- Should remote deletions ever propagate back to local state?
- Is there a scenario where remote data should override local data?

---

### 18.2 Idempotency

### Overview
Ensures that repeated operations (especially sync-related) do not create duplicate or corrupted data.

### Responsibilities
- Guarantee safe retries for sync and persistence operations.
- Prevent double-application of the same mutation.

### 18.2.1 Sync Operations

#### Idempotency Strategy
- Each log entry has a **stable, client-generated unique identifier**.
- Sync operations use **upsert semantics**, not inserts.
- Replaying the same sync payload must result in no net change.

#### Constraints
- Identifiers must:
  - Be generated before persistence.
  - Remain immutable for the life of the record.
- Sync operations must be:
  - Stateless
  - Retry-safe

#### Failure Modes
- Network retries
- App restarts mid-sync
- Partial batch uploads

---

### 18.3 Duplicate Prevention

### Overview
Prevents multiple records from representing the same real-world event.

### Responsibilities
- Detect and block duplicate creation at the earliest possible stage.
- Avoid reliance on backend-only deduplication.

### 18.3.1 Client-Side Guards

#### Mechanisms
- UUID-based primary keys generated client-side.
- Single-write flow for log creation:
  - UI → Domain → Local persistence
- No background process allowed to create logs autonomously.

#### Constraints
- A log entry is considered immutable after creation.
- Editing creates a new revision or replacement record (if supported).

#### Edge Cases
- Rapid repeated user input
- App crashes immediately after submission
- User manually re-entering identical data

---

### 18.4 Schema Evolution

### Overview
Defines how data models evolve without breaking existing installs or corrupting stored data.

### Responsibilities
- Support older data formats.
- Prevent data loss during upgrades.
- Make migrations explicit and reversible when possible.

### 18.4.1 Backward Compatibility

#### Strategy
- Schema changes must be additive whenever possible.
- Fields may be:
  - Added with defaults
  - Deprecated but not immediately removed
- Deserialization must tolerate missing fields.

#### Migration Rules
- Migrations run:
  - On app startup
  - Before data is accessed by the UI
- Failed migrations must:
  - Abort safely
  - Preserve original data

#### Assumptions
- Users may skip multiple app versions.
- Downgrades are not officially supported.

#### Open Questions
- Should schema versions be stored per-record or per-database?
- Is partial migration acceptable, or must it be all-or-nothing?

---

### 18.5 Data Repair Tools

### Overview
Provides mechanisms to recover from corruption, user error, or unexpected failures.

### Responsibilities
- Allow safe inspection and recovery of local data.
- Avoid silent data loss.

### 18.5.1 Manual Recovery Options

#### Planned Capabilities
- Clear local cache while preserving account metadata.
- Rebuild derived or aggregated data from raw logs.
- Export raw local data for external inspection.

#### Non-Goals
- Automatic silent repair without user awareness.
- Remote-triggered destructive operations.

#### Failure Modes Addressed
- Corrupted local database
- Interrupted migrations
- Partial sync states

#### Open Questions
- Should recovery tools be developer-only or user-accessible?
- Is a read-only “safe mode” needed for diagnostics?

---

### Summary Constraints

- Local storage is authoritative.
- All operations must be retry-safe.
- Duplicate creation must be prevented at the client layer.
- Schema changes must not invalidate existing data.
- Recovery paths must favor transparency over automation.

---
