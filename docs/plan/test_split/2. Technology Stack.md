## 2. Technology Stack

### 2.1 Frontend

#### 2.1.1 Flutter

##### 2.1.1.1 Version Constraints

###### Purpose
- Flutter is used to build a single codebase targeting mobile platforms with a reactive UI and strong state isolation.

###### Current State
- Flutter version: **3.22.x** (confirmed from project context)
- Dart SDK: aligned with Flutter 3.22.x constraints

###### Constraints
- Code must remain compatible with:
  - Flutter stable channel
  - Dart language features available in Flutter 3.22.x
- Avoid experimental or beta-only Flutter APIs.
- Prefer Material 3-compatible widgets where applicable.

###### Assumptions
- The project will track Flutter stable releases conservatively.
- Breaking Flutter upgrades will be gated behind manual validation.

###### Open Questions
- Is a Flutter upgrade cadence defined (e.g., quarterly, annual)?
- Is web support intentionally excluded or deferred?

---

### 2.2 State Management

#### 2.2.1 Riverpod

##### 2.2.1.1 Provider Types Used

###### Providers Observed / Intended
- `Provider`
  - Stateless dependencies (config, formatters, utilities).
- `StateProvider`
  - Simple mutable UI state (toggles, filters, selections).
- `StateNotifierProvider`
  - Core domain state (logs, sessions, accounts).
- `FutureProvider`
  - Async reads (initial loads, Firestore fetches).
- `StreamProvider`
  - Live Firestore listeners (where enabled).

###### Rationale
- Riverpod chosen over Provider/BLoC due to:
  - Compile-time safety
  - Explicit dependency graph
  - Testability without widget trees
  - Clear separation of UI and domain logic
- `StateNotifier` preferred for:
  - Predictable state transitions
  - Centralized mutation logic
- Providers scoped to features rather than global singleton usage.

###### Assumptions
- No direct mutation of state outside notifiers.
- UI layers are consumers only.

###### Open Questions
- Are `AsyncNotifier` / Riverpod 2.x patterns in use or planned?
- Is provider auto-disposal enabled consistently?

---

### 2.3 Local Persistence

#### 2.3.1 Hive

##### 2.3.1.1 Schema Management

###### Purpose
- Hive provides offline-first local persistence for:
  - Log entries
  - User/session metadata
  - Cached Firestore records

###### Schema Characteristics
- Box-per-domain model (e.g., logs, accounts, settings).
- Typed adapters for all persisted models.
- Explicit versioning via adapter changes.

###### Migration Strategy
- No implicit migrations.
- Schema changes require:
  - New adapter version
  - Manual migration logic on app startup (if needed)
- Data loss on incompatible schema changes is acceptable only if explicitly documented.

###### Constraints
- Hive boxes must open before any provider depends on them.
- Avoid storing derived or redundant data.

###### Assumptions
- Hive is the single source of truth when offline.
- Firestore sync reconciles against Hive state.

###### Open Questions
- Is there a formal adapter versioning policy?
- Are destructive migrations acceptable for any domains?

---

### 2.4 Remote Persistence

#### 2.4.1 Firebase Firestore

##### 2.4.1.1 Collection Strategy

###### Purpose
- Firestore acts as the canonical remote store for:
  - Logs
  - User accounts
  - Cross-device synchronization

###### High-Level Structure
- User-scoped collections
- Log entries stored as flat documents (no deep nesting)
- Timestamps stored in Firestore-native formats

###### Design Constraints
- Reads optimized for:
  - Time-range queries
  - Descending timestamp ordering
- Writes optimized for append-heavy workloads.

##### 2.4.1.2 Environment Separation

###### Environments
- Development
- Production

###### Separation Mechanism
- Distinct collections or collection prefixes per environment.
- Environment selected at runtime via build configuration.

###### Assumptions
- No cross-environment data access.
- Dev data is disposable.

###### Open Questions
- Are separate Firebase projects used, or only collection-level separation?
- Is there an enforced schema contract for Firestore documents?

---

### 2.5 Authentication

#### 2.5.1 Firebase Auth

##### 2.5.1.1 Account Switching Model

###### Purpose
- Support multiple user accounts within a single app installation.

###### Model Characteristics
- Firebase Auth used for identity and session tokens.
- Local account registry stored in Hive.
- Active account context determines:
  - Firestore paths
  - Local data filtering
  - UI state

###### Switching Flow
1. User selects or adds an account.
2. Firebase Auth session is refreshed or swapped.
3. Providers invalidate scoped state.
4. Hive and Firestore contexts rebind to the active account.

###### Constraints
- No shared state between accounts.
- Account switching must be deterministic and reversible.

###### Assumptions
- Refresh tokens are managed explicitly (custom refresh logic exists).
- Offline account switching is supported for already-known accounts.

###### Open Questions
- Is simultaneous multi-account sync allowed or blocked?
- What is the expected behavior when a refresh token expires?

---

### 2.6 Build & Tooling

#### 2.6.1 Flutter Toolchain

###### Tooling
- Flutter SDK (stable)
- Dart CLI
- Firebase CLI (for config and deployment)
- Platform-specific build tools:
  - Xcode (iOS)
  - Android Studio / Gradle (Android)

###### Constraints
- Builds must be reproducible from a clean checkout.
- No reliance on global, undocumented scripts.

###### Assumptions
- CI/CD integration is planned but not mandatory for local builds.

###### Open Questions
- Is there a documented CI pipeline?
- Are build flavors used beyond dev/prod?

#### 2.6.2 Platform Targets

###### Supported Targets
- Android
- iOS
- Web

###### Explicitly Out of Scope (for now)
- Desktop (Windows/macOS/Linux)

###### Assumptions
- Mobile-first UX decisions are acceptable.
- Platform-specific code is isolated behind abstractions.

###### Open Questions
- Is tablet-specific UI support required?
	- No
- Is desktop support a future goal or explicitly excluded?
	- Excluded

---

### 2.7 Open Questions / Validation Needed

- Local persistence: is **Hive** still the chosen local database, or has the project moved (or is moving) to **Isar** for offline storage?
	- We are using Hive since Isar is not supported on web
- Account switching: does the “custom refresh logic” exist in the current codebase, or is it planned/in progress?
	- Planned
- Remote environment separation: is dev/prod separation implemented via:
  - separate Firebase projects, or
  - collection/prefix separation within a single project?
	  - Different users in the same database
- Firestore schema: is there a documented/enforced schema contract (validation, versioning, required fields) for documents?
	- Not yet
