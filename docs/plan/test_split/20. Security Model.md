## 20. Security Model

### 20.1 Overview

This section defines the security assumptions, controls, and known limitations of AshTrail.
The security model is intentionally conservative and scoped to a **single-user, client-centric application** with optional cloud sync via Firebase.

AshTrail does **not** attempt to defend against a fully compromised device or a determined, well-resourced attacker. It prioritizes:
- Accidental data exposure prevention
- Proper access isolation between accounts
- Secure data transport
- Reasonable local data protection within platform constraints

---

### 20.2 Responsibilities

The security model is responsible for:
- Defining who AshTrail defends against
- Establishing boundaries of trust (client vs network vs backend)
- Ensuring Firestore access is correctly scoped per account
- Preventing cross-account data leakage
- Documenting risks inherent to offline-first storage

Out of scope:
- Malware-level device compromise
- Rooted / jailbroken device protections
- Forensic-grade local encryption guarantees

---

### 20.3 Threat Model

### 20.3.1 Assumed Adversaries

AshTrail assumes the following adversary profiles:

**In Scope**
- Curious local user with temporary device access
- Accidental data exposure (logs, backups, debug builds)
- Misconfigured Firebase rules
- Network-level passive observers (e.g., public Wi-Fi)

**Out of Scope**
- Malicious apps with root / system privileges
- Physical attackers with extended device access
- Nation-state or targeted surveillance actors
- Firebase project owner compromise

**Key Assumption**
- If the device is fully compromised, AshTrail data is considered compromised.

---

### 20.4 Client-Side Security

### 20.4.1 Local Data Protection

Local persistence is implemented using Hive (or equivalent local storage).

**Protections**
- Data is sandboxed per platform (iOS / Android app sandbox)
- No shared storage or external storage usage
- No plaintext exports without explicit user action
- Account switching clears in-memory state

**Limitations**
- Local data is readable on rooted / jailbroken devices
- OS-level backups may include local data unless excluded
- No per-record encryption keys
- No biometric or passcode gating (currently)

**Assumptions**
- OS sandboxing provides baseline isolation
- User trusts their own device environment

---

### 20.5 Network Security

### 20.5.1 TLS Assumptions

All network communication relies on Firebase SDK defaults.

**Assumptions**
- TLS is enforced for all clientâ€“Firebase communication
- Certificate validation is handled by the platform SDK
- No custom HTTP clients bypassing TLS

**Out of Scope**
- Certificate pinning
- Custom transport-layer security logic
- Defense against compromised root CAs

---

### 20.6 Firebase Rules

### 20.6.1 Firestore Access Control

Firestore is the primary remote data store when sync is enabled.

**Core Rules Principles**
- Users may only read/write documents belonging to their account
- Account ID must match authenticated user context
- No public or anonymous read access
- No cross-account queries

**Expected Rule Constraints**
- `request.auth != null`
- `request.auth.uid == resource.data.accountId`
- Collection paths scoped by account identifier

**Failure Impact**
- Misconfigured rules can result in:
  - Cross-user data exposure
  - Unauthorized writes
  - Silent data corruption

**Assumption**
- Firebase Authentication is the sole identity provider

---

### 20.7 Known Limitations

### 20.7.1 Offline Exposure Risks

AshTrail is offline-first by design, which introduces unavoidable risks.

**Risks**
- Local logs are accessible if the device is compromised
- Offline data cannot be remotely revoked or wiped
- Deleted remote data may persist locally until sync

**Non-Goals**
- Full disk encryption management
- Secure enclave integration
- Remote kill-switch behavior

**Tradeoff Rationale**
- Offline-first usability is prioritized over strict zero-trust enforcement
- App is designed for personal use, not regulated environments

---

### 20.8 Edge Cases & Failure Modes

- User signs out but local storage remains intact
- Account switching without full app restart
- Debug builds exposing logs or stack traces
- Firebase rule regression during deployment
- Partial sync failures leaving stale local data

---

### 20.9 Future Extensions (Explicitly Non-Implemented)

- Local encryption with user-derived keys
- Biometric or passcode-protected app access
- Per-account encrypted Hive boxes
- Remote wipe on account invalidation
- Certificate pinning
- Audit logging for security events

---

### 20.10 Assumptions & Open Questions

### Assumptions
- Single primary user per device
- Firebase Authentication remains trusted
- OS sandboxing is sufficient for baseline security

### Open Questions
- Should local storage be encrypted by default?
- Should app access require biometric authentication?
- Should account sign-out trigger local data purge?
- Should sensitive analytics be opt-in only?

---

---
