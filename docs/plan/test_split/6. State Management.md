## 6. State Management

### Overview
State management in AshTrail coordinates application lifecycle, account context, logging workflows, synchronization, and error handling. It is designed to support:
- Multi-account usage
- Offline-first operation
- Predictable, recoverable state transitions
- Explicit separation between transient UI state and persisted domain state

State is primarily managed using Riverpod providers, with clear ownership boundaries between global, account-scoped, and feature-specific state.

---

### Responsibilities
- Initialize application dependencies and determine startup flow
- Track and switch active accounts
- Manage in-progress and persisted log entries
- Coordinate local vs remote (Firestore) synchronization
- Surface recoverable and fatal errors consistently

---

### 6.1 Global State

#### 6.1.1 App Initialization State

#### Overview
Represents the app-wide startup lifecycle before user interaction is possible.

#### Responsibilities
- Load core services (storage, sync engine, config)
- Determine authentication and account availability
- Gate navigation until initialization completes

#### Data Structures
| Field | Type | Description |
|-----|-----|------------|
| `status` | enum | `uninitialized`, `initializing`, `ready`, `failed` |
| `error` | Error? | Initialization failure details |

#### State & Flow
1. App launch triggers `initializing`
2. Core dependencies are constructed
3. Local persistence is checked
4. App transitions to `ready` or `failed`

#### Edge Cases & Failure Modes
- Corrupted local storage
- Missing required configuration
- Partial initialization success

#### Assumptions
- Initialization runs exactly once per app launch
- No user interaction before `ready`

#### Open Questions
- Should initialization be retryable without app restart?
	- Yes, if we retry transition from the loading screen to a message letting the user know and if it fails again says itâ€™s having issues right now check for updates or try again later

---

### 6.2 Account State

#### 6.2.1 Active Account Selection

#### Overview
Tracks which account is currently active and scopes all logging and analytics operations.

#### Responsibilities
- Store active account ID
- Trigger downstream state resets on account switch

#### Data Structures
| Field               | Type    | Description                |
| ------------------- | ------- | -------------------------- |
| `activeAccountId`   | string  | Currently selected account |
| `availableAccounts` | List<?> | Locally known accounts     |


#### State & Flow
- On app start, last-used account is restored if available
- Changing the active account invalidates:
  - Logging draft state
  - Account-scoped caches
  - Sync queues

#### Edge Cases & Failure Modes
- Active account deleted locally
- Account exists locally but not remotely

#### Assumptions
- Exactly one active account at a time

---

### 6.3 Logging State

#### 6.3.1 Draft State

#### Overview
Represents in-progress, unsaved log entries.

#### Responsibilities
- Hold temporary user input
- Support partial completion and cancellation
- Validate inputs before persistence

#### Data Structures
| Field | Type | Description |
|-----|-----|------------|
| `draftId` | string | Ephemeral identifier |
| `fields` | map | Input values by field |
| `isValid` | bool | Validation result |

#### State & Flow
- Draft is created on log start
- Updated on each input change
- Discarded on cancel or successful save

#### Edge Cases & Failure Modes
- App backgrounded mid-draft
- Account switch with active draft

#### Assumptions
- Draft state is never persisted automatically

---

### 6.3.2 Persisted State

#### Overview
Represents saved log entries stored locally and optionally synced remotely.

#### Responsibilities
- Provide immutable access to saved logs
- Serve as the source of truth for analytics

#### Data Structures
| Field | Type | Description |
|-----|-----|------------|
| `logId` | string | Stable identifier |
| `timestamp` | DateTime | Log time |
| `data` | map | Structured log payload |
| `syncStatus` | enum | `local`, `pending`, `synced`, `conflict` |

#### State & Flow
- Draft transitions to persisted on save
- Persisted logs enter sync pipeline

---

### 6.4 Sync State

#### 6.4.1 Pending Changes

#### Overview
Tracks local changes awaiting remote synchronization.

#### Responsibilities
- Queue unsynced operations
- Retry failed sync attempts

#### Data Structures
| Field | Type | Description |
|-----|-----|------------|
| `pendingLogs` | List<logId> | Logs awaiting sync |
| `lastAttempt` | DateTime? | Last sync attempt |

#### State & Flow
- New persisted logs are marked `pending`
- Sync engine processes queue when online

#### Edge Cases & Failure Modes
- Large offline backlog
- Repeated transient network failures

---

### 6.4.2 Conflict State

#### Overview
Represents detected divergence between local and remote data.

#### Responsibilities
- Surface conflicts to resolution logic
- Prevent silent overwrites

#### Data Structures
| Field | Type | Description |
|-----|-----|------------|
| `conflictingLogId` | string | Affected log |
| `localVersion` | LogEntry | Local data |
| `remoteVersion` | LogEntry | Remote data |

#### Assumptions
- Conflicts are rare and explicit

#### Open Questions
- Will conflict resolution be automatic or user-driven?

---

### 6.5 Error State

#### 6.5.1 Recoverable Errors

#### Overview
Errors that allow continued app operation.

#### Responsibilities
- Inform the user
- Allow retry or graceful degradation

#### Examples
- Network unavailable
- Temporary sync failure
- Validation errors

---

### 6.5.2 Fatal Errors

#### Overview
Errors that prevent safe continuation.

#### Responsibilities
- Halt affected flows
- Provide diagnostic context

#### Examples
- Unrecoverable data corruption
- Initialization failure

#### Assumptions
- Fatal errors require app restart or reinstall

---

### Future Extensions
- Time-travel debugging for state transitions
- Per-account error isolation
- Background sync progress state
- Formal state machine definitions for critical flows

---
