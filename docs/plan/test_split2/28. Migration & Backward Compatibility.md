## 28. Migration & Backward Compatibility

### 28.0 Overview

AshTrail is **offline-first** with a **local database as the source of truth** and Firestore as an optional sync/backup layer. Migration exists to:

- Preserve user data across app releases.
- Evolve local schemas (Isar) and remote document shapes (Firestore) without requiring data loss.
- Ensure older clients fail safely (or continue working) when newer data exists.

**Current status (from project documentation outline):**
- Isar schema changes are **manual and developer-managed** today (i.e., no fully automated, fully documented migration history yet).  
- Migration strategy must therefore prioritize **explicit versioning**, **safe defaults**, and **failure recovery**.

---

### 28.1 Local Schema Migration

#### 28.1.1 Version Detection

Local schema migration must answer two questions on startup (per account):

1. **What schema version is on disk?**
2. **What schema version does this build expect?**

Because AshTrail is multi-account, version detection must be **per account storage**, not global.

**Recommended sources of truth (pick one and be consistent):**
- **Isar schema version** (preferred): open Isar with a `schemaVersion` and a migration callback.
- **App-managed version stamp** (secondary): store `localSchemaVersion` alongside account metadata (e.g., in account-scoped settings / prefs).

**Required properties:**
- Version is a monotonically increasing integer.
- Version is read before any writes.
- Version is stored per account (since each account has an independent local store).

~~~text
Per-account migration decision (conceptual)

onAppStart:
  for each activeAccount:
    vDisk = readLocalSchemaVersion(account)
    vCode = CURRENT_LOCAL_SCHEMA_VERSION
    if vDisk == vCode: continue
    if vDisk > vCode: enter "downgrade" mode (see rollback strategy)
    else: runMigrations(account, from=vDisk, to=vCode)
~~~

---

#### 28.1.2 Migration Execution Model

**Principles**
- Migrations must be **explicit** (no silent breaking changes).
- Migrations must be **idempotent** when possible.
- Migrations must be **atomic** at the user-data level (either fully migrated or recoverable).

**Recommended structure**
- A migration registry keyed by integer version:
  - `vN -> vN+1` steps only (no giant “do everything” blob).
- Each step declares:
  - What collections are affected.
  - Whether the step is destructive.
  - Whether the step requires a backup.

~~~dart
// Pseudocode shape (not implementation-verified)
typedef MigrationStep = Future<void> Function(Isar isar);

final migrationSteps = <int, MigrationStep>{
  1: migrateV1ToV2,
  2: migrateV2ToV3,
};
~~~

**Execution constraints**
- Run migrations **before** starting sync.
- Block UI writes to the affected account until migration completes.
- Prefer showing a dedicated “Migrating account data…” screen if migration is non-trivial.

---

### 28.2 Remote Data Migration

Firestore is schemaless, so “migration” is primarily about **backward/forward compatible document evolution** and **sync logic compatibility**.

#### 28.2.1 Firestore Changes

**Rules for Firestore schema evolution**
- Prefer **additive changes**:
  - Add new optional fields.
  - Do not rename/remove fields until you have an explicit compatibility plan.
- Clients must:
  - Treat unknown fields as ignorable.
  - Treat missing fields as defaultable.
- Any breaking semantic change should be gated behind:
  - A `docVersion` field, or
  - A feature flag / protocol version in sync metadata.

**Recommended document version stamp**
- Add an integer `docVersion` (or equivalent) on each synced document type **or** within a per-account sync metadata document.
- Version is written by new clients; old clients ignore it.

~~~json
{
  "docVersion": 3,
  "createdAt": "2025-12-29T17:21:10Z",
  "updatedAt": "2025-12-29T17:22:45Z",
  "payload": { "...": "..." }
}
~~~

**Handling truly breaking changes**
If a field rename or type change is unavoidable:
- Support a **dual-read** period:
  - Read `newField` if present, else fall back to `oldField`.
- Support a **dual-write** period (optional but safest):
  - Write both fields for a period so older clients still function.
- After sufficient deprecation time, stop writing the old field.

**No server-side jobs constraint**
Project constraints indicate “no server-side jobs” as an operational constraint (at least currently). Therefore:
- Remote “backfills” should be avoided.
- If a backfill becomes necessary, treat it as a **future extension** and document the operational change explicitly.

---

### 28.3 User Impact

#### 28.3.1 Downtime Expectations

**Local migration**
- Expected downtime is **only on first launch after upgrading** and **per account**.
- Typical user experience:
  - App opens → detects schema mismatch → blocks account usage → migrates → resumes.
- The “downtime” is device-local (no Firestore requirement), unless the chosen recovery path involves re-sync.

**Remote changes**
- Properly additive Firestore changes should cause **zero downtime**.
- If sync protocol changes, users may see:
  - Sync paused with a “requires upgrade” error (preferred to corruption).
  - Partial sync until both sides converge on compatible logic.

**Minimum UX requirements**
- A clear message when migration is happening and which account is affected.
- A clear error when migration fails:
  - What happened
  - Whether data is safe
  - What the user can do next (retry / restore / export / reset)

---

### 28.4 Rollback Strategy

Rollback is about **failure recovery**, not “downgrading the app” (downgrades are inherently hostile to forward-only schemas).

#### 28.4.1 Failure Recovery

**Local migration failure recovery (preferred order)**
1. **Transactional/atomic migration** (if supported by the operation pattern):
   - Ensure partial writes can be detected and safely retried.
2. **Pre-migration backup snapshot** (recommended for any destructive step):
   - Copy/export the local database (or critical collections) before running destructive migrations.
3. **Restore from backup**
   - If migration fails, restore snapshot and keep the account in “migration required” mode.
4. **Rebuild from remote (last resort)**
   - If Firestore is enabled and trusted enough:
     - Wipe local store for the account
     - Re-sync from remote
   - This must be explicit because local is normally authoritative.

**Downgrade handling**
If the app detects `vDisk > vCode` (local schema newer than this build supports):
- Do not attempt to “reverse migrate” silently.
- Fail safe:
  - Mark account as “requires newer app version”
  - Block writes
  - Allow export if possible (read-only tools)

~~~text
Downgrade safe behavior (conceptual)
- Show: "This account’s data was created by a newer version of AshTrail."
- Actions:
  - Update app
  - Export data (if supported)
  - Remove account from device (explicit destructive)
~~~

**Remote rollback (Firestore)**
Because Firestore is schemaless, rollback is typically about client logic:
- Keep changes backward compatible as long as possible.
- If dual-write was used, stopping new writes is usually sufficient.
- Avoid deleting fields remotely unless there is a strong reason and a documented plan.

---

### 28.5 Edge Cases & Failure Modes

- **Skipped versions** (e.g., v1 → v5 upgrade):
  - Must apply migrations sequentially.
- **Partial migration due to crash / OS kill**:
  - Must detect “in-progress” marker and resume or restore.
- **Insufficient disk space for backup**:
  - Migration must fail before destructive steps.
- **Local corruption detected pre-migration**:
  - Offer recovery options: export what’s readable, reset local, re-sync (if enabled).
- **Multi-account isolation breach**:
  - A migration must never read/write another account’s database or version stamp.
- **Firestore shape drift**:
  - Remote docs missing expected fields must not crash sync; default or quarantine invalid docs.

---

### 28.6 Future Extensions

- **Formal migration ledger**
  - Document every schema version with:
    - Date introduced
    - Collections impacted
    - Data transformation notes
- **Migration test harness**
  - Fixture databases for each historical schema version + automated upgrade tests.
- **Structured “repair mode”**
  - A dedicated screen/tooling for:
    - Exporting raw data
    - Rebuilding derived aggregates
    - Re-syncing a single account
- **Optional server-side backfill**
  - Only if operational constraints change (introduces costs and reliability concerns).
  - Must be gated behind an ADR and explicit deployment documentation.

---

### Assumptions & Open Questions (Migration)

**Assumptions**
- Isar is the local persistence layer and schema changes are manual today.
- Firestore is the only remote backend currently planned.

**Open Questions**
- Where is the **current local schema version** defined in code (Isar `schemaVersion` vs app-managed stamp)?
- Is there an existing **migration registry** or are migrations handled ad-hoc per release?
- Is there an existing **backup/export** mechanism that can be reused for pre-migration snapshots?
- Do Firestore documents already include any **version/protocol markers**?
- What is the intended behavior when a user installs an older build over newer data (read-only/export vs hard block)?

---
