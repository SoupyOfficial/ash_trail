## 29. Observability & Diagnostics

### 1. Overview

Observability & Diagnostics covers the mechanisms used to:
- Understand how AshTrail is being used (locally, privacy-preserving)
- Diagnose issues during development and in the field
- Collect user-provided diagnostic artifacts (log bundles) without leaking sensitive data

This section exists because:
- A privacy-first app still needs actionable diagnostics
- Offline-first behavior makes “repro it on my machine” less reliable
- Multi-account data increases the risk of leaking identifiers if diagnostics aren’t explicitly designed

> Assumption: AshTrail avoids third-party telemetry by default and favors local-only diagnostics.  
> Open question: Is there any remote crash reporting (e.g., Crashlytics/Sentry) planned or currently used?

---

### 2. Responsibilities

#### 29.1 Metrics (Usage Metrics)
- Define what “usage metrics” mean in AshTrail (local counters/timestamps, not external analytics by default)
- Store metrics in a way that is:
  - Cheap to write
  - Safe to export (after redaction)
  - Optional and disable-able (feature-flag or build-mode gated)

#### 29.2 Debug Views (Internal Screens)
- Provide internal UI screens to:
  - Inspect local state and caches
  - Inspect sync state (if applicable)
  - Inspect logs and export a diagnostic bundle
- Ensure these screens are not available in production builds (or are strongly gated)

#### 29.3 User-Reported Issues (Log Bundles)
- Generate a diagnostic artifact that users can share (e.g., file export/share sheet)
- Include enough context to debug without including sensitive user content
- Support deterministic reproduction signals (versions, build flavor, device info, feature flags)

#### 29.4 Privacy Constraints (Data Redaction)
- Prevent leaking:
  - Account identifiers that can be tied back to a person
  - Auth tokens / refresh tokens / session cookies
  - Free-form user notes (if any exist)
  - Raw timestamps if they are considered sensitive for the use case (policy decision)

---

### 3. Data structures (fields, types, constraints)

> Note: Exact storage entities depend on the existing local DB schema. The structures below define recommended fields and constraints for a diagnostics subsystem. If AshTrail already has concrete entities for logs/metrics, replace these with the implementation-accurate structures.

#### 29.1 Usage metrics

**UsageMetric (conceptual)**
- `id`: string (unique; UUID recommended)
- `key`: string  
  - Example keys: `appLaunch`, `logCreate`, `exportStarted`, `exportCompleted`, `syncAttempted`
- `count`: int  
  - Monotonic non-negative
- `firstSeenAt`: datetime (optional)
- `lastSeenAt`: datetime (optional)
- `scope`: enum[`global`, `account`]  
  - `account` scope requires a stable but *redactable* reference to account
- `accountRef`: string?  
  - MUST NOT be a raw email/username/token  
  - Prefer: internal UUID (still redactable) or derived anonymized id

**Constraints**
- No metric should store free-form user input
- If per-account metrics exist, account identifiers must be redactable during export

#### 29.2 Debug view state

**DebugViewModel (conceptual UI state)**
- `isEnabled`: bool (should be false in production unless explicitly turned on)
- `sections`: enum[] (e.g., `logs`, `metrics`, `db`, `sync`, `featureFlags`, `device`)
- `filters`: json? (log level, time window, account scope)

#### 29.3 Log bundle contents

**LogBundleManifest (conceptual)**
- `bundleId`: string (UUID)
- `createdAt`: datetime
- `appVersion`: string
- `buildFlavor`: enum[`dev`, `prod`] (or project-defined flavors)
- `platform`: enum[`android`, `ios`]
- `osVersion`: string?
- `deviceModel`: string?
- `locale`: string?
- `timezone`: string?
- `enabledFlags`: string[]? (only flags that are safe to disclose)
- `redactionProfile`: enum[`strict`, `standard`] (policy choice)
- `files`: array of:
  - `path`: string (relative path inside bundle)
  - `sha256`: string? (optional integrity check)
  - `bytes`: int

**Bundle file types (recommended)**
- `manifest.json`
- `logs.ndjson` (or `logs.json`)
- `metrics.json`
- `sync_state.json` (if sync exists)
- `db_snapshot.json` (ONLY if safe and redacted; often too risky)

#### 29.4 Redaction configuration

**RedactionRule (conceptual)**
- `name`: string
- `type`: enum[`regex`, `jsonPath`, `keyMatch`]
- `pattern`: string
- `replacement`: string (default: `"[REDACTED]"`)
- `appliesTo`: enum[`logs`, `metrics`, `manifest`, `all`]

**RedactionProfile**
- `profile`: enum[`strict`, `standard`]
- `rules`: RedactionRule[]

---

### 4. State & flow (how data moves through the system)

#### 29.1 Usage metrics flow
1. App event occurs (launch, log creation, export, etc.)
2. Metric recorder increments a counter and updates `lastSeenAt`
3. Metrics are stored locally (DB or lightweight key-value store)
4. Debug view can display metrics
5. Export pipeline reads metrics and applies redaction (if any account scoping exists)
6. Metrics included in log bundle

**Open questions**
- Where are metrics stored today (Isar/SQLite/shared_preferences/other)?
- Are metrics intended to be per-account or global-only?

#### 29.2 Debug views flow (internal screens)
1. Debug entry point is enabled by:
   - Build mode (debug/profile only), and/or
   - Feature flag, and/or
   - Hidden gesture / secret menu (still risky in prod)
2. Debug screens read from:
   - Local DB
   - In-memory state (e.g., Riverpod providers)
   - Log buffer
3. Debug screens provide actions:
   - Copy-to-clipboard JSON
   - Export log bundle
   - Reset local caches (dangerous; should require confirmation)

**Failure mode requirement**
- Debug screens must not crash the app if underlying data is malformed; they should show partial results and errors.

#### 29.3 User-reported issues flow (log bundles)
1. User initiates “Create Diagnostics Bundle”
2. App builds `manifest.json` (version/build/device/flags)
3. App collects:
   - Logs (bounded window)
   - Metrics
   - Sync state (if applicable)
4. App runs redaction pass across collected artifacts
5. App packages bundle:
   - Preferred: `.zip`
   - Alternative: single `.json` with embedded arrays
6. App invokes platform share/export UI
7. User attaches bundle to a bug report (email, issue tracker, etc.)

**Open questions**
- What sharing mechanism is used (Android share sheet / iOS share sheet / in-app email)?
- Are bundles encrypted at rest before sharing, or only stored in temp storage?

#### 29.4 Redaction flow
1. Export pipeline enumerates all included artifacts
2. Applies redaction rules by artifact type
3. Validates output:
   - No known sensitive keys present (tokens, auth headers)
   - No emails/phone numbers (if that policy exists)
4. Writes redacted artifacts into bundle

---

### 5. Edge cases & failure modes

#### Metrics
- Counter corruption (negative or overflow)
  - Mitigation: clamp at `>= 0`; reset with note in logs
- Metrics store unavailable (DB locked, migration failure)
  - Mitigation: metrics become best-effort; do not block primary features

#### Debug views
- Debug screens accidentally available in production
  - Mitigation: compile-time gating + runtime checks
  - Add automated test/assertion that debug routes are absent in release builds
- Debug screens expose raw PII
  - Mitigation: debug UI should default to redacted display, with a “show raw” control available only in dev

#### Log bundles
- Bundle too large
  - Mitigation: bounded log ring buffer; time-window selection; size cap
- Bundle creation fails mid-way (disk full, permission denied)
  - Mitigation: partial bundle with manifest + error summary; surface actionable message
- Timezone/locale mismatch causing confusion during triage
  - Mitigation: include both local timestamps and UTC timestamps in manifest (policy decision)

#### Redaction
- Redaction misses a sensitive field due to new code paths
  - Mitigation: centralized redaction rules + unit tests with known “canary” strings
- Over-redaction makes bundle useless
  - Mitigation: profiles (`strict` vs `standard`) and explicit documentation of what is removed

---

### 6. Future extensions (clearly labeled)

#### Optional: Structured logging
- Move from unstructured strings to structured log events:
  - `eventName`, `level`, `timestamp`, `context` (json)
- Benefits:
  - Safer redaction
  - Easier filtering in debug views
  - Better export stability

#### Optional: Diagnostics “repro recipe”
- Include:
  - Recent navigation route history (redacted)
  - Last N domain events (e.g., “log created”, “sync attempted”)
- Helps reproduce bugs without needing raw user data

#### Optional: In-app issue reporting
- Flow:
  - User describes issue (free text)
  - App auto-attaches log bundle
  - User consents to include specific fields
- Requires strong privacy UX and explicit opt-in

#### Optional: Local “health checks”
- Simple checks with results included in bundle:
  - DB schema version
  - Pending sync queue length
  - Storage available
  - Clock drift estimate (if relevant)

---

### Assumptions & Open Questions (Summary)

### Assumptions
- Observability is local-first; exports are user-initiated
- Debug views are not available in production builds by default
- Log bundles are redacted before leaving the device

### Open Questions
- What logging library/mechanism is used today (and is there a bounded ring buffer)?
- Where are usage metrics stored and what is their scope (global vs per account)?
- Is any third-party crash reporting used (now or planned)?
- What is the exact export format (zip vs json) and what files are included?
- What is the official redaction policy (emails, timestamps, account ids, user notes)?

---
