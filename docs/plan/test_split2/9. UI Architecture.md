## 9. UI Architecture

### Overview
The UI Architecture defines how screens, navigation, widgets, and forms are structured and composed in AshTrail.  
Its primary goals are:

- Predictable navigation across core workflows
- Clear separation between UI, state, and domain logic
- Reusable, testable widgets
- Accessibility and platform-consistent behavior

This layer consumes state from Riverpod providers and emits user intent events. It must not contain business logic.

---

### Responsibilities
- Define navigation structure and routes
- Render screens based on application and account state
- Collect user input and surface validation feedback
- Provide reusable UI components
- Ensure baseline accessibility support

---

### 9.1 Navigation

### Overview
Navigation coordinates movement between high-level screens such as logging, history, and analytics.  
Navigation must be state-aware (e.g., active account, initialization complete).

---

### Responsibilities
- Declare routes and route names
- Control screen transitions
- Prevent navigation into invalid app states

---

### 9.1.1 Route Definitions

#### Data Structures
Routes are defined as named paths mapped to screen widgets.

| Field | Type | Description |
|-----|-----|------------|
| routeName | string | Unique route identifier |
| builder | WidgetBuilder | Screen constructor |
| requiresAccount | bool | Whether an active account is required |

#### State & Flow
- App startup resolves initialization state
- If no account is active, navigation is restricted
- Route changes are triggered by user actions or state changes

#### Assumptions
- Routing is centralized (not defined per-feature)
- Deep linking is not currently required

#### Open Questions
- Is declarative routing (e.g., Router API) planned?
- Should routes encode account IDs explicitly?

---

### 9.2 Screens

### Overview
Screens represent full-page UI surfaces.  
Each screen:
- Subscribes to relevant providers
- Delegates logic to controllers or services
- Renders composed widgets

---

### 9.2.1 Logging Screen

#### Responsibilities
- Capture new log entries
- Display current session context
- Submit validated log data

#### State & Flow
1. User selects log type
2. Input widgets update local form state
3. Validation runs on submit
4. Valid entries are persisted via logging controller
5. UI resets or advances based on result

#### Edge Cases
- Submission attempted with no active account
- Partial input for multi-field log types
- Rapid repeated submissions

---

### 9.2.2 History View

#### Responsibilities
- Display persisted log entries
- Support filtering and grouping
- Reflect account-scoped data

#### State & Flow
- Subscribes to log history provider
- Reacts to account switch events
- Rebuilds on data sync or local mutation

#### Edge Cases
- Empty history state
- Large datasets impacting scroll performance
- Logs created offline then synced

---

### 9.2.3 Analytics View

#### Responsibilities
- Visualize aggregated log data
- React to time range and filter changes
- Display derived metrics only (no raw mutation)

#### State & Flow
- Reads pre-aggregated analytics state
- Triggers recomputation via state changes
- Renders charts and summaries

#### Assumptions
- Analytics are read-only from the UI layer
- Heavy computation is not performed in widgets

---

### 9.3 Widgets

### Overview
Widgets are composable UI building blocks used across screens.

---

### 9.3.1 Reusable Components

#### Examples
- Labeled input rows
- Primary / secondary buttons
- Section headers
- Empty-state placeholders

#### Constraints
- Widgets must be stateless where possible
- Stateful widgets must not own business logic
- Styling is centralized via theme definitions

---

### 9.4 Forms

### Overview
Forms handle structured user input and validation feedback.

---

### 9.4.1 Input Handling

#### Responsibilities
- Maintain transient form state
- Normalize user input
- Emit submission intent

#### State & Flow
- Local form state tracks field values
- On change: update state only
- On submit: trigger validation pipeline

---

### 9.4.2 Validation Feedback

#### Responsibilities
- Surface field-level errors
- Prevent invalid submission
- Display global submission failures

#### Validation Types
- Required fields
- Type constraints (number, duration)
- Cross-field dependencies

#### Edge Cases
- Validation rules changing between app versions
- Legacy logs not matching new constraints

---

### 9.5 Accessibility Considerations

### Overview
Accessibility ensures the app remains usable across devices and user settings.

---

### 9.5.1 Text Scaling

#### Responsibilities
- Respect system text scale factor
- Avoid clipped or overlapping text
- Maintain readable layouts at large sizes

#### Constraints
- No fixed-height text containers
- Layouts must reflow vertically

#### Open Questions
- Is screen reader (TalkBack / VoiceOver) support explicitly targeted?
- Are color-contrast audits planned?

---

### Future Extensions
- Declarative navigation with guarded routes
- Deep linking support
- Keyboard navigation for tablets and desktop
- Full screen reader semantics annotations

---
