# Feature Implementation Prompt: Global Error Boundary & Retry Surface (ui.error_boundary)

This prompt is auto-generated by dev_assistant `start-next-feature` to guide AI / developer implementation.
Do not remove architectural guardrails. Keep changes minimal, tested, and aligned with Clean Architecture.

## Context
Epic: ui
Priority: P1  Status: in_progress

## Rationale
(None provided)

## Acceptance Criteria
- Uncaught UI errors show fallback with Restart and Copy Logs (dev) actions.
- Boundary logs sanitized error event (respects analyticsOptIn).
- Unit tests cover error boundary capturing and reset logic.
- Share diagnostics uses native iOS share sheet (redacted if analyticsOptIn=false).

## Components / Modules
- error_boundary

## Output Contract (Reminders)
The PR for this feature should include in order:
1. Plan (goal, assumptions, acceptance)
2. Files changed list (paths + purpose)
3. Code (full files, no TODO placeholders)
4. Tests (unit/widget/integration as applicable)
5. Docs diffs / ADR additions (if architectural decisions changed)
6. Manual QA steps (including offline & error paths)
7. Performance & Accessibility checks
8. Conventional commit message (subject <=72 chars)

## Finalization Workflow
Before requesting a PR: repeatedly run the dry-run finalize until all validations pass.
Command: python scripts/dev_assistant.py finalize-feature --feature-id {feature_id} --dry-run --json
Check JSON: validations.tests_ok, validations.coverage_ok (>= ${MIN_PROJECT_COV}% line), validations.todos_ok all true.
If any false: add/adjust tests, raise coverage, or complete checklist (AI_PROMPT). Re-run dry-run.
Only when all pass: run without --dry-run to auto-stage + commit (optionally add --push).
Never commit partial feature via finalize-feature; use normal git commits for intermediate work.
Always run all tests locally before finalize-feature.

## Implementation Guidance
1. Maintain feature-first folder structure (domain, data, presentation).
2. Expose public API via Riverpod providers; avoid direct Firestore/Dio in widgets.
3. Add Freezed entities & DTO mappers; ensure serialization isolated.
4. Implement use cases (pure) in domain layer returning Either<AppFailure, T>.
5. Add minimal tests: mapper, use case happy path + one failure, provider logic.
6. Respect performance & accessibility notes above.
7. Update feature status to in_progress only if delivering code (already auto-set).
8. Keep AI generated explanations concise in PR body; no large boilerplate.

## Initial TODO Checklist
- [x] Define domain entities / value objects (if new).
- [x] Add use cases (list in code comment).
- [x] Create repository interface + impl placeholders.
- [x] Wire Riverpod providers (autoDispose where suitable).
- [x] Implement presentation widgets/screens behind feature flag if needed.
- [x] Write unit tests (â‰¥85% for new lines).
- [x] Update docs / ADR if architectural decisions differ.

## Do Not
- Introduce new heavy dependencies without ADR.
- Bypass error handling (always map to AppFailure).
- Expose raw exceptions or Firestore documents to UI.

(End of prompt)
